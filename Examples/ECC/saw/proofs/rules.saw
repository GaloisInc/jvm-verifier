////////////////////////////////////////////////////////////////////////////////
// Rewrite Rules
//
// This section defines common rules for verification tasks that use the
// rewrite.
// 
// Strategies for creating rewrite rules:
//   Push split and join towards bottom of terms.
//   Prefer join to split in equals.
//   Cancel unnessary applications wherever possible
//     with cancelation/elimination rules.

// Misc cancelation rules

rule eq_elim    : forAll {x:a}. x == x -> true;
rule join_split : forAll {x:[384]}. join(split(x) : [12][32]) -> x;
rule not_not    : forAll {x:Bit}. not(not(x)) -> x;
rule eq_elim    : forAll {x:a}. x == x -> true;
rule split_join : forAll {x:[12][32]}. split(join(x) : [384]) : [12][32] -> x;

rule join_split2 : forAll {x:[768]}. join(split(x) : [24][32]) -> x;
rule split_join1 : forAll {x:[24][32]}. split(join(x) : [768]) : [24][32] -> x;

// Boolean elimination rules 

rule and_true_elim1  : forAll {x:Bit}. true && x -> x;
rule and_true_elim2  : forAll {x:Bit}. x && true -> x;
rule and_false_elim1 : forAll {x:Bit}. false && x -> false;
rule and_false_elim2 : forAll {x:Bit}. x && false -> false;
rule and_left_assoc  : forAll {x:Bit, y:Bit, z:Bit}.  x && (y && z) -> (x && y) && z;
// rule and_contr_elim1 : forAll {x:Bit}. x && not x -> false;
// rule and_contr_elim2 : forAll {x:Bit}. not x && x -> false;

rule or_true_elim1  : forAll {x:Bit}. true || x -> true;
rule or_true_elim2  : forAll {x:Bit}. x || true -> true;
rule or_false_elim1 : forAll {x:Bit}. false || x -> x;
rule or_false_elim2 : forAll {x:Bit}. x || false -> x;
rule or_trivial     : forAll {x:Bit}. not x || x -> true;

rule or_redundant1  : forAll {x:Bit,y:Bit}. (x || y) || y -> x || y;
rule or_redundant2  : forAll {x:Bit,y:Bit}. (x || y) || x -> x || y;
rule and_redundant1 : forAll {x:Bit,y:Bit}. (x && y) && y -> x && y;
rule and_redundant2 : forAll {x:Bit,y:Bit}. (x && y) && x -> x && y;

//rule imp_true_elim1  : forAll {x:Bit}. x     ==> true  -> true;
/*
rule imp_true_elim2  : forAll {x:Bit}. true  ==> x     -> x;
rule imp_false_elim1 : forAll {x:Bit}. x     ==> false -> x;
rule imp_false_elim2 : forAll {x:Bit}. false ==> x     -> true;
*/

// De Morgan's 
rule not_or  : forAll {x:Bit, y:Bit}. not (x || y) -> not x && not y;
rule not_and : forAll {x:Bit, y:Bit}. not (x && y) -> not x || not y;

// Generic ite rules 

rule ite_not :
  forAll { b:Bit, x:a, y:a }.
    (if (not b) then x else y) -> if b then y else x;

rule ite_elim_1 : forAll { b:Bit, x:a, y:a, z:a }.
  (if b then (if b then x else y) else z)
  -> if b then x else z;

rule ite_elim_2 : forAll { b:Bit, x:a, y:a, z:a }.
  (if b then x else (if b then y else z))
  -> if b then x else z;

rule ite_bit : forAll {b:Bit, c:Bit, d:Bit}.
  if b then c else d -> (not b || c) && (b || d);

// Bit-level ite rules

rule ite_bit_false_1 :
  forAll { b:Bit, c:Bit }.
    (if b then false else c) -> not b && c;

rule ite_bit_true_1 :
  forAll { b:Bit, c:Bit }.
    (if b then true else c) -> b || c;

// Congruence rules for ite 

rule ite_eq_cong_1 :
  forAll { b:Bit, x:a, y:a, z:a }.
    (if b then x else y) == z -> if b then (x == z) else (y == z);

rule ite_eq_cong_2 :
  forAll { b:Bit, x:a, y:a, z:a }.
    z == (if b then x else y) -> if b then (z == x) else (z == y);

rule ite_split_cong :
  forAll { b:Bit, x:[384], y:[384] }.
    split(if b then x else y) : [12][32] -> 
      if b then split(x) : [12][32] else split(y) : [12][32];

rule ite_join_cong :
  forAll { b:Bit, x:[12][32], y:[12][32] }.
    join(if b then x else y) -> 
      if b then join(x) else join(y);

// Eq-split rules

let zeroArray = split(0:[384]) : [12][32];
let unitArray = split(1:[384]) : [12][32];

rule eq_split_cong_1 : forAll {x:[384], y:[12][32]}.
  split(x):[12][32] == y -> x == join(y);

rule eq_split_cong_2 : forAll {x:[12][32], y:[384]}.
  x == split(y):[12][32] -> join(x) == y;

// Special purpose eq-split rules
// N.B. In the long term, it should be able to write more general rules
// than this.

rule eq_split_valueOf_zeroArray : forAll { x:[12][32]}.
  x == zeroArray -> join(x) == 0:[384];

rule eq_split_valueOf_unitArray : forAll { x:[12][32]}.
  x == unitArray -> join(x) == 1:[384];

// Record elimination rules

rule jacobianX :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.x -> x0;

rule jacobianY :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.y -> y0;

rule jacobianZ :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.z -> z0;

rule affineX :
  forAll { x0 : a, y0 : a }.
    { x = x0 ; y = y0 }.x -> x0;

rule affineY :
  forAll { x0 : a, y0 : a }.
    { x = x0 ; y = y0 }.y -> y0;

////

rule trunc_shift_get : forAll {x:[384], s:[9]}.
  trunc (x >>u s) : [32] ->
  aget (split(x) : [12][32], (s >>u 5:[9]) # 0:[23]);

// Field-specific elimination rules

rule ite_zero_field_mul :
  forAll { x:[384], y:[384], z:[384], c:Bit }.
    (if (x == 0:[384]) then (ref_field_mul(x, y) == z:[384]) else c)
     -> (if (x == 0:[384]) then (z:[384] == 0:[384]) else c);
