// Define operators from SBV files.
extern SBV is_field("sbv/ref_p384_is_val.sbv")  : [384] -> Bit;
extern SBV field_add("sbv/ref_p384_add.sbv") : ([384],[384]) -> [384];
extern SBV field_sub("sbv/ref_p384_sub.sbv") : ([384],[384]) -> [384];
extern SBV field_mul("sbv/ref_p384_mul.sbv") : ([384],[384]) -> [384];
extern SBV field_mod("sbv/ref_p384_mod.sbv") : [768] -> [384];
extern SBV field_sq("sbv/ref_p384_sq.sbv") : [384] -> [384];
extern SBV field_div_step("sbv/ref_p384_div_step.sbv") :
  ([12][32], [12][32], [12][32], [12][32], [12][32], [32]) ->
  { a:[12][32]; ra:[12][32]; b:[12][32]; rb:[12][32]; sw:[32] };
extern SBV ec_double("sbv/p384_ref_double.sbv") :
  { x: [384]; y: [384]; z: [384] } -> { x:[384]; y:[384]; z:[384] };
extern SBV field_half("sbv/ref_p384_half.sbv") : [384] -> [384];
extern SBV field_neg("sbv/ref_p384_neg.sbv") : [384] -> [384];
extern SBV ec_full_add("sbv/p384_ref_full_add.sbv") :
  ({ x: [384]; y: [384]; z: [384] }, { x:[384]; y:[384] }) ->
  { x:[384]; y:[384]; z:[384] };
extern SBV ec_full_sub("sbv/p384_ref_full_sub.sbv") :
  ({ x: [384]; y: [384]; z: [384] }, { x:[384]; y:[384] }) ->
  { x:[384]; y:[384]; z:[384] };
extern SBV ec_mul_aux("sbv/p384_ref_mul_aux.sbv") :
  ({ x: [384]; y: [384]; z: [384] }, { x:[384]; y:[384] }, [32], [32], [32]) ->
  { x:[384]; y:[384]; z:[384] };
extern SBV ec_mul("sbv/p384_ref_mul.sbv") :
  ([384], { x:[384]; y:[384] }) -> { x:[384]; y:[384]; z:[384] };

// Define field prime for P384 curve (taken from NIST and NSA documents).
let field_prime = <| 2^384 - 2^128 - 2^96 + 2^32 - 1 |> : [384];

// Array operation verification {{{1

method com.galois.ecc.P384ECC64.is_zero {
  var args[0] :: int[12];
  returns: if join(valueOf(args[0])) == 0:[384] then 1:[32] else 0:[32];
  verifyUsing: abc;
};

method com.galois.ecc.P384ECC64.set_zero {
  var args[0] :: int[12];
  ensures valueOf(args[0]) := split(0:[384]) : [12][32];
  verifyUsing: abc;
};

method com.galois.ecc.P384ECC64.set_unit {
  var args[0] :: int[12];
  ensures valueOf(args[0]) := split(1:[384]) : [12][32];
  verifyUsing: abc;
};

method com.galois.ecc.P384ECC64.assign {
  var args[0], args[1] :: int[12];
  ensures valueOf(args[0]) := valueOf(args[1]);
  verifyUsing: abc;
};

// Field operation verification {{{1

// field_add {{{2
//
// field_add takes three valueOfs as arguments: args[0], args[1], and args[2].
// To avoid allocating memory, it stores the result of adding args[1] and args[2]
// into the first argument "args[0]".
method com.galois.ecc.P384ECC64.field_add {
  // Simulator types for references must give explicit length for valueOfs.

  // Note: If debugging information is available, we could eventually support
  // using the argument names from the Java debugging information.  However, for
  // our initial release, arguments must be refered to by position.
  var args[0], args[1], args[2] :: int[12];

  // Allow any of the valueOfs to alias the other valueOfs.
  // Complicates verification, but necessary for correctness of higher-level
  // operations such as "ec_double".
  mayAlias { args[0], args[1], args[2] };

  // Require Java this.field_prime field equals SAWScript field_prime constant.
  const valueOf(this.field_prime) := split(field_prime) : [12][32];

  // Result of executing method.
  // In this case, we store the result of adding args[1] and args[2] inside of
  // args[0].
  ensures valueOf(args[0]) := 
    split(field_add(join(valueOf(args[1])), join(valueOf(args[2])))) : [12][32];

  // Verification method:
  //  Can be one of:
  //   * "skip" for skiping verification.
  //   * "abc" for bitblasting and using ABC to solve resulting SAT problem.
  //   * "rewriter" for using rewriting, and succeeding if verification reduces
  //      to "True".
  // verifyUsing: abc;
  verifyUsing: quickcheck 100;
};

// field_sub {{{2

method com.galois.ecc.P384ECC64.field_sub {
  var args[0], args[1], args[2] :: int[12];
  mayAlias { args[0], args[1], args[2] };
  const valueOf(this.field_prime) := split(field_prime) : [12][32];
  ensures valueOf(args[0]) :=
    split(field_sub(join(valueOf(args[1])), join(valueOf(args[2])))) : [12][32];
  verifyUsing: abc;
};

// field_dbl {{{2

method com.galois.ecc.P384ECC64.field_dbl {
  var args[0], args[1] :: int[12];
  mayAlias { args[0], args[1] };
  const valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jarg1 = join(valueOf(args[1]));
  ensures valueOf(args[0]) := split(field_add(jarg1, jarg1)) : [12][32];
  verifyUsing: abc;
};

// field_dbl_dec {{{2

rule eq_elim : forAll {x:a}. x == x -> True;

rule join_split : forAll {x:[384]}.
  join(split(x) : [12][32]) -> x;

method com.galois.ecc.P384ECC64.field_dbl_dec {
  var args[0], args[1] :: int[12];
  const valueOf(this.field_prime) := split(field_prime) : [12][32];

  // Require that args[0] and args[1] are valid field elements.
  // assume is_field(join(valueOf(args[0])));
  // assume is_field(join(valueOf(args[1])));

  let jarg0 = join(valueOf(args[0]));
  let jarg1 = join(valueOf(args[1]));
  ensures valueOf(args[0]) := split(field_sub(field_sub(jarg0, jarg1), jarg1)) : [12][32];
  verifyUsing: rewriter;
};

// field_mul3 {{{2

method com.galois.ecc.P384ECC64.field_mul3 {
  // Require arguments are 12-element integer valueOfs.
  var args[0], args[1] :: int[12];

  // Require Java this.field_prime field equals SAWScript field_prime constant.
  const valueOf(this.field_prime) := split(field_prime) : [12][32];

  // assume is_field(join(valueOf(args[0])));
  // assume is_field(join(valueOf(args[1])));

  // Let jarg1 equals args[1] value as a single 384-bit number.
  let jarg1 = join(valueOf(args[1]));

  // Store result of jarg1 + jarg1 + jarg1 inside first argument valueOf.
  ensures valueOf(args[0]) := split(field_add(jarg1, field_add(jarg1, jarg1))) : [12][32];

  verifyUsing: abc;
};

// field_mul4 {{{2
method com.galois.ecc.P384ECC64.field_mul4 {
  var args[0], args[1] :: int[12];
  mayAlias { args[0], args[1] };
  const valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jarg1 = join(valueOf(args[1]));
  let dbl = field_add(jarg1, jarg1);
  ensures valueOf(args[0]) := split(field_add(dbl, dbl)) : [12][32];
  verifyUsing: abc;
};

// field_mul8 {{{2
method com.galois.ecc.P384ECC64.field_mul8 {
  var args[0], args[1] :: int[12];
  mayAlias { args[0], args[1] };
  const valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jarg1 = join(valueOf(args[1]));
  let dbl = field_add(jarg1, jarg1);
  let quad = field_add(dbl, dbl);
  ensures valueOf(args[0]) := split(field_add(quad, quad)) : [12][32];
  verifyUsing: abc;
};

// field_red {{{2
method com.galois.ecc.P384ECC64.field_red {
  var args[0] :: int[12];
  var args[1] :: int[24];

  const valueOf(this.field_prime) := split(field_prime) : [12][32];
  ensures valueOf(args[0]) := split(field_mod(join(valueOf(args[1])))) : [12][32];

  verifyUsing: quickcheck 100;
};

// field_mul {{{2
method com.galois.ecc.P384ECC64.field_mul {
  // Require arguments are 12-element integer valueOfs.
  var args[0], args[1], args[2] :: int[12];
  // Require "this.a" is a temporary buffer capable of storing 24 integers.
  var this.a :: int[24];

  // Allow three arguments to alias.
  mayAlias { args[0], args[1], args[2] };

  // Require that args[1] and args[2] are valid field elements.
  // assume is_field(join(valueOf(args[1])));
  // assume is_field(join(valueOf(args[2])));

  // Require Java this.field_prime field equals SAWScript field_prime constant.
  const valueOf(this.field_prime) := split(field_prime) : [12][32];

  // Store result of args[1] * args[2] inside args[0].
  ensures valueOf(args[0]) := split(field_mul(join(valueOf(args[1])), join(valueOf(args[2])))) : [12][32];

  // Indicate that the value of this.a after execution may be an arbitrary value.
  // This is implemented in symbolic simulator by creating a new fresh variable
  // after executing field_mul.
  modifies: valueOf(this.a);

  // Test field_mul using quickcheck.
  //verifyUsing: quickcheck 100;
  verifyUsing: skip;
};

// field_sq {{{2
method com.galois.ecc.P384ECC64.field_sq {
  var args[0], args[1] :: int[12];
  var this.a :: int[24];
  mayAlias { args[0], args[1] };
  // assume is_field(join(valueOf(args[1])));
  const valueOf(this.field_prime) := split(field_prime) : [12][32];
  ensures valueOf(args[0]) := split(field_mul(join(valueOf(args[1])), join(valueOf(args[1])))) : [12][32];
  modifies: valueOf(this.a);
  verifyUsing: skip;
};

// mod_half {{{2
method com.galois.ecc.P384ECC64.mod_half {
  var args[0] :: int[12];
  // assume that second argument is field_prime;
  const valueOf(args[1]) := split(field_prime) : [12][32];
  ensures valueOf(args[0]) := split(field_half(join(valueOf(args[0])))) : [12][32];
  verifyUsing: abc;
};

set verification off;

// mod_div {{{2
method com.galois.ecc.P384ECC64.mod_div {
  /* Arguments: ra, x, y, p */

  /* We'll use the convention that args[0] refers to the initial value
  of the first argument, while locals[ra] refers to the current value
  of the local variable associated with the argument. Similarly for
  other arguments. All of the following variables are distinct. None
  of these refereces alias. */

  var args[0], args[1], args[2], args[3] :: int[12];
  var this.t1, this.t2, this.t3 :: int[12];

  /*
  State:
  ra -- interpreted as rb when sw is true
  x -- never changes
  y -- never changes
  p -- never changes
  a -- interpreted as b when sw is true
  b -- interpreted as a when sw is true
  rb -- interpreted as ra when sw is true
  swapped -- indicates whether a and b are swapped
  */
  //var locals[swapped] :: int;

  /* The following locals each alias one of the arrays declared above.
  In practice, we don't need separate names for x, y, and p. They
  always point to args[1], args[2], and args[3], respectively, and
  never change. We might leave them out of this list to indicate that
  they never change? */

  var locals[ra], locals[x], locals[y], locals[p], locals[a],
      locals[b], locals[rb] :: int[12];

  const valueOf(this.field_prime) := split(field_prime) : [12][32];

  /* One local specification for the point right before the while loop
  starts. This spec states that the initialization happens correctly.
  Ultimately, the model of this initialization may come from an
  external file, for easy comparison with Cryptol (as in the comments
  below), but for the moment we encode it explicitly using SAWScript
  primitives. Essentially, this describes what initial arguments are
  provided to the Cryptol EGCD function, in terms of the arguments
  provided to the division function . */
  localSpec 42 {
    // let initres = field_div_init(args[0], args[1], args[2], args[3],
    //                              this.t1, this.t2, this.t3,
    //                              locals[swapped]);
    // ensures valueOf(this.t1) := initres.a;
    // ensures valueOf(args[0]) := initres.ra
    // ensures valueOf(this.t2) := initres.b;
    // ensures valueOf(this.t3) := initres.rb;
    // ensures locals[swapped] := false;
    ensures valueOf(this.t1) := valueOf(args[3]);
    ensures valueOf(args[0]) := split(0 : [384]) : [12][32];
    ensures valueOf(this.t2) := valueOf(args[2]);
    ensures valueOf(this.t3) := valueOf(args[1]);
    ensures locals[a] := this.t1;
    ensures locals[b] := this.t2;
    ensures locals[ra] := args[0];
    ensures locals[rb] := this.t3;
    //ensures swapped := 0;
  };

  /* One local specification for the end of the body of the while
  loop. This states that the loop body performs the same operation as
  the field_div_step function from the Cryptol spec. */
  localSpec 142 {
    /* Question: should we pass the 'canonical' names here (such as
    args[0]), along with the 'swapped' variable? Or should we pass the
    'local' names (such as ra), and leave out 'swapped'? */
    /*
    let stepres = field_div_step(args[0], args[1], args[2], args[3],
                                 this.t1, this.t2, this.t3,
                                 locals[swapped]);
    ensures valueOf(this.t1) := stepres.a;
    ensures valueOf(args[0]) := stepres.ra;
    ensures valueOf(this.t2) := stepres.b;
    ensures valueOf(this.t3) := stepres.rb;
    */
    //ensures locals[swapped] :=  stepres.sw;

    /* One possible implementation choice for the moment would be that
    when we re-start we only execute 'ensures' clauses that describe
    reference values. And, for those, if they're conditional, they all
    need the same condition, and we fork: one execution where that
    condition is true and one where it's false. */

    /*
    if local[swapped] {
      ensures
    } else {
    }
    */
    //ensures locals[a] := ite(locals[swapped], this.t2, this.t1);
    //ensures locals[b] := ite(locals[swapped], this.t1, this.t2);
    //ensures locals[ra] := ite(locals[swapped], this.t3, args[0]);
    //ensures locals[rb] := ite(locals[swapped], args[0], this.t3);
  };

  /* This final cleanup code just copies ra into rb if swapped is
  true. */
  /*
  let finalres = field_div_finish(args[0], args[1], args[2], args[3],
                                  this.t1, this.t2, this.t3,
                                  locals[swapped]);
  ensures valueOf(args[0]) := finalres.ra;
  */
  modifies: valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);

  verifyUsing: abc;
};

set verification on;

// Point operation verification {{{1

// Diable field operations.
//disable is_field;
//disable field_add;
//disable field_sub;

// Define rules for rewriting verification {{{2

// Strategies used in creating rewrite rules.
//   Push split and join towards bottom of terms.
//   Prefer join to split in equals.
//   Cancel unnessary applications wherever possible
//     with cancelation/elimination rules.

// Misc cancelation rules{{{3
rule not_not : forAll {x:Bit}.  not(not(x)) -> x;
rule eq_elim : forAll {x:a}. x == x -> True;

rule join_split : forAll {x:[384]}.
  join(split(x) : [12][32]) -> x;

// Boolean elimination rules {{{3

rule and_true_elim1 : forAll {x:Bit}. True && x -> x;
rule and_true_elim2 : forAll {x:Bit}. x && True -> x;
rule and_false_elim1 : forAll {x:Bit}. False && x -> False;
rule and_false_elim2 : forAll {x:Bit}. x && False -> False;
rule and_left_assoc : forAll {x:Bit, y:Bit, z:Bit}.
 x && (y && z) -> (x && y) && z;

rule or_true_elim1 : forAll {x:Bit}. True || x -> True;
rule or_true_elim1 : forAll {x:Bit}. x || True -> True;
rule or_false_elim1 : forAll {x:Bit}. False || x -> x;
rule or_false_elim2 : forAll {x:Bit}. x || False -> x;

// Move not inside {{{3
rule not_or : forAll {x:Bit, y:Bit}.
  not (x || y) -> not x && not y;
rule not_and : forAll {x:Bit, y:Bit}.
  not (x && y) -> not x || not y;

rule or_trivial : forAll {x:Bit}. not x || x -> True;

// Redundancy {{{3
rule or_redundant1 : forAll {x:Bit,y:Bit}. (x || y) || y -> x || y;
rule or_redundant2 : forAll {x:Bit,y:Bit}. (x || y) || x -> x || y;
rule and_redundant1 : forAll {x:Bit,y:Bit}. (x && y) && y -> x && y;
rule and_redundant2 : forAll {x:Bit,y:Bit}. (x && y) && x -> x && y;

// Generic ite rules {{{3
rule ite_not :
  forAll { b:Bit, x:a, y:a }.
    (if (not b) then x else y) -> if b then y else x;
rule ite_elim_1 : forAll { b:Bit, x:a, y:a, z:a }.
  (if b then (if b then x else y) else z)
  -> if b then x else z;
rule ite_elim_2 : forAll { b:Bit, x:a, y:a, z:a }.
  (if b then x else (if b then y else z))
  -> if b then x else z;
rule ite_bit : forAll {b:Bit, c:Bit, d:Bit}.
  if b then c else d -> (not b || c) && (b || d);

// Bit level ite rules {{{3
rule ite_bit_false_1 :
  forAll { b:Bit, c:Bit }.
    (if b then False else c) -> not b && c;

rule ite_bit_true_1 :
  forAll { b:Bit, c:Bit }.
    (if b then True else c) -> b || c;

// Eq-split rules{{{3

let zeroArray = split(0:[384]) : [12][32];
let unitArray = split(1:[384]) : [12][32];

rule eq_split_cong_1 : forAll {x:[384], y:[12][32]}.
  split(x):[12][32] == y -> x == join(y);
rule eq_split_cong_2 : forAll {x:[12][32], y:[384]}.
  x == split(y):[12][32] -> join(x) == y;

// Special purpose rules
// N.B. In the long term, it should be able to write more general rules
// than this.
rule eq_split_valueOf_zeroArray : forAll { x:[12][32]}.
  x == zeroArray -> join(x) == 0:[384];
rule eq_split_valueOf_unitArray : forAll { x:[12][32]}.
  x == unitArray -> join(x) == 1:[384];

// ite congruence rules {{{3

rule ite_eq_cong_1 :
  forAll { b:Bit, x:a, y:a, z:a }.
    (if b then x else y) == z -> if b then (x == z) else (y == z);
rule ite_eq_cong_2 :
  forAll { b:Bit, x:a, y:a, z:a }.
    z == (if b then x else y) -> if b then (z == x) else (z == y);
rule ite_split_cong :
  forAll { b:Bit, x:[384], y:[384] }.
    split(if b then x else y) : [12][32] -> 
      if b then split(x) : [12][32] else split(y) : [12][32];
rule ite_join_cong :
  forAll { b:Bit, x:[12][32], y:[12][32] }.
    join(if b then x else y) -> 
      if b then join(x) else join(y);

// Record elimination rules {{{3

rule jacobianX :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.x -> x0;
rule jacobianY :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.y -> y0;
rule jacobianZ :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.z -> z0;

rule affineX :
  forAll { x0 : a, y0 : a }.
    { x = x0 ; y = y0 }.x -> x0;
rule affineY :
  forAll { x0 : a, y0 : a }.
    { x = x0 ; y = y0 }.y -> y0;


// Field-specific elimination rules {{{3

rule field_sq_def :
  forAll { x:[384] }.
   field_sq(x) -> field_mul(x, x);

rule ite_zero_field_mul :
  forAll { x:[384], y:[384], z:[384], c:Bit }.
    (if (x == 0:[384]) then (field_mul(x, y) == z:[384]) else c)
     -> (if (x == 0:[384]) then (z:[384] == 0:[384]) else c);

// }}}3

// ec_double {{{2
enable ec_double;
// Point doubling spec.
// Point doubling take a single Jacobian point and modifies it's fields so that
// they refer to the point after it has been doubled.
// It uses some temporary buffers for storing results, but allocates no new memory.
method com.galois.ecc.P384ECC64.ec_double {
  // Indicate type for argument.
  var args[0] :: com.galois.ecc.JacobianPoint;
  // Indicate type for fields of Java JacobianPoint.
  var args[0].x, args[0].y, args[0].z :: int[12];
  // Provide types for temporary buffers.
  var this.a :: int[24];
  var this.t1, this.t2 :: int[12];

  // Require that fields for Jacobian point are valid field elements.
  // assume is_field(join(valueOf(args[0].x)));
  // assume is_field(join(valueOf(args[0].y)));
  // assume is_field(join(valueOf(args[0].z)));

  // Constants
  const valueOf(this.field_prime) := split(field_prime) : [12][32];

  // Let res denote the Cryptol struct formed from Cryptol ec_double operation.
  let res = ec_double({ x = join(valueOf(args[0].x)) ; y = join(valueOf(args[0].y)) ; z = join(valueOf(args[0].z)) });

  // Split results of Cryptol operation into Java fields.
  ensures valueOf(args[0].x) := split(res.x) : [12][32];
  ensures valueOf(args[0].y) := split(res.y) : [12][32];
  ensures valueOf(args[0].z) := split(res.z) : [12][32];

  // Indicate temporary buffers are modifies.
  modifies: valueOf(this.a), valueOf(this.t1), valueOf(this.t2);

  // Use rewriting to verify ec_double.
  verifyUsing: rewriter;
};
disable ec_double;

// ec_full_add {{{2
enable ec_full_add;
method com.galois.ecc.P384ECC64.ec_full_add {
  var args[0] :: com.galois.ecc.JacobianPoint;
  var args[1] :: com.galois.ecc.AffinePoint;
  var this.a :: int[24];
  var this.t1, this.t2, this.t3 :: int[12];
  var args[0].x, args[0].y, args[0].z :: int[12];
  var args[1].x, args[1].y :: int[12];
  assume is_field(join(valueOf(args[0].x)));
  assume is_field(join(valueOf(args[0].y)));
  assume is_field(join(valueOf(args[0].z)));
  assume is_field(join(valueOf(args[1].x)));
  assume is_field(join(valueOf(args[1].y)));
  const valueOf(this.field_prime) := split(field_prime) : [12][32];
  let res =
    ec_full_add(
      { x = join(valueOf(args[0].x)) ; y = join(valueOf(args[0].y)) ; z = join(valueOf(args[0].z)) },
      { x = join(valueOf(args[1].x)) ; y = join(valueOf(args[1].y)) }
      );
  ensures valueOf(args[0].x) := split(res.x) : [12][32];
  ensures valueOf(args[0].y) := split(res.y) : [12][32];
  ensures valueOf(args[0].z) := split(res.z) : [12][32];
  modifies: valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  verifyUsing: skip;
};

// ec_full_sub {{{2
method com.galois.ecc.P384ECC64.ec_full_sub {
  var args[0] :: com.galois.ecc.JacobianPoint;
  var args[1] :: com.galois.ecc.AffinePoint;
  var this.a  :: int[24];
  var this.t1, this.t2, this.t3 :: int[12];
  var args[0].x, args[0].y, args[0].z :: int[12];
  var args[1].x, args[1].y            :: int[12];
  assume is_field(join(valueOf(args[0].x)));
  assume is_field(join(valueOf(args[0].y)));
  assume is_field(join(valueOf(args[0].z)));
  assume is_field(join(valueOf(args[1].x)));
  assume is_field(join(valueOf(args[1].y)));
  const valueOf(this.field_prime) := split(field_prime) : [12][32];
  let res =
    ec_full_sub(
      { x = join(valueOf(args[0].x)) ; y = join(valueOf(args[0].y)) ; z = join(valueOf(args[0].z)) },
      { x = join(valueOf(args[1].x)) ; y = join(valueOf(args[1].y)) }
      );
  ensures valueOf(args[0].x) := split(res.x) : [12][32];
  ensures valueOf(args[0].y) := split(res.y) : [12][32];
  ensures valueOf(args[0].z) := split(res.z) : [12][32];
  modifies: valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  verifyUsing: skip;
};

// ec_mul_merge_aux {{{2
method com.galois.ecc.P384ECC64.ec_mul_merge_aux {
  var args[0] :: com.galois.ecc.JacobianPoint;
  var args[1] :: com.galois.ecc.AffinePoint;
  var args[2] :: int;
  var args[3] :: int;
  var args[4] :: int;
  var this.a :: int[24];
  var this.t1, this.t2, this.t3 :: int[12];
  var args[0].x, args[0].y, args[0].z :: int[12];
  var args[1].x, args[1].y :: int[12];
  assume is_field(join(valueOf(args[0].x)));
  assume is_field(join(valueOf(args[0].y)));
  assume is_field(join(valueOf(args[0].z)));
  assume is_field(join(valueOf(args[1].x)));
  assume is_field(join(valueOf(args[1].y)));
  const valueOf(this.field_prime) := split(field_prime) : [12][32];
  let res = ec_mul_aux({ x = join(valueOf(args[0].x))
                       ; y = join(valueOf(args[0].y))
                       ; z = join(valueOf(args[0].z))
                       },
                       { x = join(valueOf(args[1].x))
                       ; y = join(valueOf(args[1].y))
                       },
                       args[2],
                       args[3],
                       args[4]);
  ensures valueOf(args[0].x) := split(res.x) : [12][32];
  ensures valueOf(args[0].y) := split(res.y) : [12][32];
  ensures valueOf(args[0].z) := split(res.z) : [12][32];
  modifies: valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  verifyUsing: skip;
  //verifyUsing: rewriter;
};

// ec_mul {{{2
method com.galois.ecc.P384ECC64.ec_mul {

  var args[0] :: com.galois.ecc.JacobianPoint;
  var args[0].x, args[0].y, args[0].z :: int[12];
  var args[1] :: int[12];
  var args[2] :: com.galois.ecc.AffinePoint;
  var args[2].x, args[2].y            :: int[12];

  var this.a  :: int[24];
  var this.h  :: int[12];
  var this.t1, this.t2, this.t3       :: int[12];

  assume is_field(join(valueOf(args[1])));
  assume is_field(join(valueOf(args[2].x)));
  assume is_field(join(valueOf(args[2].y)));

  const valueOf(this.field_prime) := split(field_prime) : [12][32];

  /*
  localSpec 162 {
      let lres = ec_mul_aux(
                   { x = join(valueOf(args[0].x))
                   ; y = join(valueOf(args[0].y))
                   ; z = join(valueOf(args[0].z))
                   },
                   { x = join(valueOf(args[2].x))
                   ; y = join(valueOf(args[2].y))
                   },
                   TODO,
                   TODO,
                   TODO);
      ensures: valueOf(args[0].x) := split(lres.x);
      ensures: valueOf(args[0].y) := split(lres.y);
      ensures: valueOf(args[0].z) := split(lres.z);

  }
  */

  let res = ec_mul(join(valueOf(args[1])),
                   { x = join(valueOf(args[2].x))
                   ; y = join(valueOf(args[2].y))
                   });

  ensures valueOf(args[0].x) := split(res.x) : [12][32];
  ensures valueOf(args[0].y) := split(res.y) : [12][32];
  ensures valueOf(args[0].z) := split(res.z) : [12][32];
  /*modifies: valueOf(args[0].x), valueOf(args[0].y), valueOf(args[0].z);*/
  modifies: valueOf(this.a), valueOf(this.h), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);

  verifyUsing: skip;
};
