include "Field.cry"; /* Defines Field type and generic operations */

/* Core bit-level operations. {{{1 */

/* Unsigned word extension. */
uext : {a b} (b >= a, fin a) => [a] -> [b];
uext(x) = x # zero;

iext : {a b} (b >= a, fin a) => [a] -> [b];
iext(x) = x # (if x!0 then ~zero else zero);

/* Returns the (n+1)-bit sum of two n-bit numbers. */
safe_add : {n} (fin n) => ([n],[n]) -> [n+1];
safe_add(x,y) = uext(x) + uext(y);

/* returns the (n+1)-bit subtraction of two n-bit numbers. */
safe_sub : {n} (fin n) => ([n],[n]) -> [n+1];
safe_sub(x,y) = uext(x) - uext(y);

/* Is x in normalized form (relative to prime p)? */
is_normal : {a} (fin a) => [a] -> [a] -> Bit;
is_normal p x = (x < p);

/* Returns the product of two inputs. */
safe_product : {a} (fin a) => ([a],[a]) -> [2*a];
safe_product(x,y) = uext(x) * uext(y);

/* Returns module reduction on input. */
safe_mod : {a b} (fin a, fin b) => ([b],[a]) -> [b];
safe_mod(p,x) = take(width(p), (x # zero) % (p # zero));

/* Add two n-bit numbers and input carry to obtain a n bit number and output carry. */
adc : {n} (fin n) => ([n],[n]) -> ([n],Bit);
adc(x,y) = (take(width x,sum), sum @ width x)
  where sum = safe_add(x,y);

/* sbb(x,y) subtracts y from x, and returns result along with output borrow bit. */
sbb : {n} (fin n) => ([n],[n]) -> ([n],Bit);
sbb(x,y) = (take(width x, r), ~(r ! 0))
  where r = (x # [True]) - (y # [False]);

/* Field primitives common to group and underlying field. {{{1 */

/* Add two numbers in normalized form. */
mod_add : {n} (fin n) => ([n],[n],[n]) -> [n];
mod_add(p,x,y) = if c1 | ~c2 then r2 else r1
  where {
    (r1,c1) = adc( x, y);
    (r2,c2) = sbb(r1, p);
  };

/* Subtract two numbers in normalized form. */
mod_sub : {n} (fin n) => ([n],[n],[n]) -> [n];
mod_sub(p,x,y) = if b then r2 else r1
  where {
    (r1,b) = sbb( x, y);
    (r2,_) = adc(r1, p);
  };

mod_neg : {n} (fin n) => ([n],[n]) -> [n];
mod_neg(p,x) = if x == 0 then 0 else (p - x);

mod_half : {n} (fin n, n >= 1) => ([n],[n]) -> [n];
mod_half(p, x) = if even(x) then x >> 1
                 else drop(1, safe_add(x, p))
  where { even x = (x & 1) == 0; };

/* Definition of modular multiplication. */
mod_mul : {n} (fin n) => ([n],[n],[n]) -> [n];
mod_mul(p,x,y) = safe_mod(p, safe_product(x, y));

/* Returns x/y in F_p using Euler's binary gcd algorithm. */
/* Taken from [HMV] */
mod_div : {a} (fin a, a >= 1) => ([a],[a],[a]) -> [a];
mod_div(p,x,y) = egcd(p,0,y,x)
  where {
    /* In code below, a is always odd. */
    egcd(a,ra,b,rb) =
      if b == 0 then
        ra
      else if (b & 1) == 0 then /* b is even. */
        egcd(a, ra, b >> 1, mod_half(p, rb))
      else if a < b then
        egcd(a, ra, (b - a) >> 1, mod_half(p, mod_sub(p, rb, ra)))
      else 
        egcd(b, rb, (a - b) >> 1, mod_half(p, mod_sub(p, ra, rb)));
    pragma egcd: ISABELLE skipTerminationProof;
  };

/* Point operations {{{1 */

type AffinePoint fv = { x : fv; y : fv; };

/* Return an affine point. */
nzAffinePoint : {fv} (fv,fv) -> AffinePoint fv;
nzAffinePoint (ax,ay) = { x = ax; y = ay };

/* Define Jacobian points */
type JacobianPoint fv = { x : fv; y : fv; z : fv; };

/* Create affine point from Jacobian (only well-defined if z coordinate is non-zero). */
ec_affinify : {fv} (Field fv, JacobianPoint fv) -> AffinePoint fv;
ec_affinify(f,s) = { x = f.mul(g2, s.x); y = f.mul(g3, s.y); }
  where { g = f.div(f.field_unit, s.z); g2 = f.sq(g); g3 = f.mul(g, g2); };

/* Create projective value from affine. */
/* Routine 2.2.1 in [NSA 2008] */
ec_projectify : {fv} (Field fv, AffinePoint fv) -> JacobianPoint fv;
ec_projectify(f,s) = { x = s.x; y = s.y; z = f.field_unit };

/* Returns zero point. */
ec_zero_point : {fv} Field fv -> JacobianPoint fv;
ec_zero_point(f) = { x = f.field_unit; y = f.field_unit; z = f.field_zero };

/* Checks to see if point is zero. */
ec_is_zero_point : {fv} (Field fv, JacobianPoint fv) -> Bit;
ec_is_zero_point(f,s) = f.is_equal(s.z, f.field_zero);

/* Is the Jacobian point well-formed? Here we assume
** the only valid zero-point is the unit zero point.
** NOTE: The output of ECC operations in this file always
**   satisfies this assumption. However, they are more
**   permissive in their inputs, i.e. they still do the
**   right thing when given a non-unit zero point.
*/
is_JacobianPoint : {fv} (fin fv) => Field fv -> Set (JacobianPoint fv);
is_JacobianPoint f s =
  ( f.is_val ((s:JacobianPoint fv).x)
  & f.is_val (s.y)
  & f.is_val (s.z)
  & implies (ec_is_zero_point (f,s))
            (s == ec_zero_point f)
  );

type PointOps (fv,gv) = {
       field : Field fv;
       double : JacobianPoint fv -> JacobianPoint fv;
       add : (JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv;
       sub : (JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv;
       group_field : Field gv;
     };

/* Double a Jacobian point */
/* Line numbers taken from Routine 2.2.6 in [NSA 2008] */
/* This version uses 4 multiplies and 4 squarings (4M + 4S).  The paper
   "A software implementation of NIST P-224" by Bernstein 2001 has a
   version that uses 3M + 5S.
   In that version, there are the following correspondances
     r7  = delta
     r11 = alpha
     r14 = gamma
     r15 = beta
     r16 = 4*beta
     r17 = alpha^2
     r18 = x3 = alpha^2 - 8*beta
     r12 = y1 * z1
   The key difference is to replace the computation of r13
    with "r13 = (s.y + s.z)^2 - s.y^2 - s.z^2".
   */
ec_double : {fv} (Field fv, JacobianPoint fv) -> JacobianPoint fv;
ec_double(f,s) =
  if is_zero(s.z) then
    { x = f.field_unit; y = f.field_unit; z = f.field_zero; } /* 5: r <- (1,1,0) and return */
  else
    { x = r18; y = r23; z = r13; }
 where {
   add = f.add;
   sub = f.sub;
   mul = f.mul;
   is_zero(x) = f.is_equal(x, f.field_zero);
   dbl(x) = f.add(x, x);
   mul3(x) = f.add(x, f.add(x, x));
   mul4(x) = dbl(dbl(x));
   mul8(x) = dbl(mul4(x));

   r7  = f.sq(s.z);          /*  7: t4 <- (t3)^2 */
   r8  = f.sub(s.x, r7);     /*  8: t5 <- t1 - t4 */
   r9  = add(s.x, r7);       /*  9: t4 <- t1 + t4 */
   r10 = mul(r9, r8);        /* 10: t5 <- t4 * t5 */
   r11 = mul3(r10);          /* 11: t4 <- 3 * t5 */
   r12 = mul(s.z, s.y);      /* 12: t3 <- t3 * t2 */
   r13 = dbl(r12);           /* 13: t3 <- 2 * t3 */
   r14 = f.sq(s.y);          /* 14: t2 <- (t2)^2 */
   r15 = mul(s.x, r14);      /* 15: t5 <- t1 * t2 */
   r16 = mul4(r15);          /* 16: t5 <- 4 * t5 */
   r17 = f.sq(r11);          /* 17: t1 <- (t4)^2 */    
   r18 = sub(sub(r17, r16), r16); /* 18: t1 <- t1 - 2 * t5 */
   r19 = f.sq(r14);          /* 19: t2 <- (t2)^2 */
   r20 = mul8(r19);          /* 20: t2 <- 8 * t2 */ 
   r21 = sub(r16, r18);      /* 21: t5 <- t5 - t1 */
   r22 = mul(r11, r21);      /* 22: t5 <- t4 * t5 */ 
   r23 = sub(r22, r20);      /* 23: t2 <- t5 - t2 */
  };

/**
 * Add a Jacobian point to an affine point over the given field.
 * Note: Will return { 0, 0, 0 } if points are equivalent, and double should be
 *       called.
 * Algorithm comes from Routine 2.2.7 in [NSA 2008].
 */
ec_add : {fv gv} (PointOps (fv, [gv]), JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv;
ec_add(p,s,t) =
  if is_zero(r13) then
    if is_zero(r14) then
      p.double(s) /* 17: r <- (0,0,0) and return */
    else
      { x = p.field.field_unit; y = p.field.field_unit; z = p.field.field_zero; } /* 19: r <- (1,1,0) and return */
  else
    { x = r32; y = r37; z = r27 }
  where {
   add = p.field.add;
   sub = p.field.sub;
   mul = p.field.mul;
   sq  = p.field.sq;
   is_zero(x) = p.field.is_equal(x, p.field.field_zero);
   dbl(x) = add(x, x);
   dbl_dec(x, y) = sub(sub(x, y), y);
   /* Line numbers from Routine 2.2.7 definition. */

   r9 = sq(s.z);             /*  9: t7 <- (t3)^2 */
   r10 = mul(t.x, r9);       /* 10: t4 <- t4 * t7 */
   r11 = mul(s.z, r9);       /* 11: t7 <- t3 * t7 */
   r12 = mul(t.y, r11);      /* 12: t5 <- t5 * t7 */
   r13 = sub(s.x, r10);      /* 13: t4 <- t1 - t4 */
   r14 = sub(s.y, r12);      /* 14: t5 <- t2 - t5 */

   r22 = sub(dbl(s.x), r13); /* 22: t1 <- 2*t1 - t4 */
   r23 = sub(dbl(s.y), r14); /* 23: t2 <- 2*t2 - t5 */

   r27 = mul(s.z, r13);      /* 27: t3 <- t3 * t4 */
   r28 = sq(r13);            /* 28: t7 <- (t4)^2 */
   r29 = mul(r13, r28);      /* 29: t4 <- t4 * t7 */
   r30 = mul(r22, r28);      /* 30: t7 <- t1 * t7 */
   r31 = sq(r14);            /* 31: t1 <- (t1)^2 */
   r32 = sub(r31, r30);      /* 32: t1 <- t1 - t7 */
   /*r33 = sub(r30, dbl(r32));*/ /* 33: t7 <- t7 - 2*t1 */
   /* The following is a better match for the Java implementation. */
   r33 = dbl_dec(r30, r32);  /* 33: t7 <- t7 - 2*t1 */
   r34 = mul(r14, r33);      /* 34: t5 <- t5 * t7 */
   r35 = mul(r23, r29);      /* 35: t4 <- t2 * t4 */
   r36 = sub(r34, r35);      /* 36: t2 <- t5 - t4 */
   r37 = p.field.half(r36);  /* 37: t2 <- t2/2 */
  };

/* Add Jacobian point to an affine point over the given field. */
/* Algorithm comes from Routine 2.2.8 in [NSA 2008] */
ec_full_add : {fv gv} (fin gv) => (PointOps (fv, [gv]), JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv;
ec_full_add(p, s, t) =
  if is_zero(s.z) then
    { x = t.x; y = t.y; z = p.field.field_unit }
  else
    ec_add(p, s, t)
 where {
   is_zero(x) = p.field.is_equal(x, p.field.field_zero);
 };

/* Subtract affine point from Jacobian point over the given field. */
/* Algorithm comes from Routine 2.2.9 in [NSA 2008] */
ec_full_sub : {fv gv} (PointOps (fv, [gv]), JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv;
ec_full_sub(p, s, t) = p.add(s, { x = t.x; y = p.field.neg(t.y); });

/* Scalar multiply operations {{{1 */

/* Multiplies a large word scalar by the an affine point. */
ec_mul : {fv gv}  (fin gv) => (PointOps (fv, [gv]), [gv], AffinePoint fv) -> JacobianPoint fv;
ec_mul (m, d, s) = res@`(gv+1)
  where {
    k = d # [False False];
    h = k + (k + k);
    res : [inf](JacobianPoint fv);
    res = [(ec_zero_point(m.field))]
          #  [| if hi & ~ki then
                  m.add(m.double(r), s)
                else if ~hi  & ki then
                  m.sub(m.double(r), s)
                else
                  m.double(r)
             || hi <- reverse(h) # zero
             || ki <- reverse(k) # zero
             || r  <- res |];
    };


ec_twin_mul_aux1 : {fv gv} (fin gv, gv >= 4) => 
  (PointOps (fv,[gv]), JacobianPoint fv, [2], [2], 
   AffinePoint fv, AffinePoint fv, AffinePoint fv, AffinePoint fv) 
  -> (JacobianPoint fv);
ec_twin_mul_aux1(m,rP,u0,u1,sPt,s,sMt,t) = r
  where {
   f = m.field;
   r = if      (u0 == -1) & (u1 == -1) then m.sub(r2, sPt)
       else if (u0 == -1) & (u1 ==  0) then m.sub(r2, s)
       else if (u0 == -1) & (u1 ==  1) then m.sub(r2, sMt)
       else if (u0 ==  0) & (u1 == -1) then m.sub(r2, t)
       else if (u0 ==  0) & (u1 ==  1) then m.add(r2, t)
       else if (u0 ==  1) & (u1 == -1) then m.add(r2, sMt)
       else if (u0 ==  1) & (u1 ==  0) then m.add(r2, s)
       else if (u0 ==  1) & (u1 ==  1) then m.add(r2, sPt)
       else r2
         where r2 = m.double(rP);
  };

p384_ec_twin_mul_aux1 : 
  (JacobianPoint [384], [32], [32], AffinePoint [384], AffinePoint [384], AffinePoint [384], AffinePoint [384])
  -> JacobianPoint [384];
p384_ec_twin_mul_aux1(rP, u0_32, u1_32, sPt, s, sMt, t) =
  ec_twin_mul_aux1(p384_point_ops, rP, take(2, u0_32), take(2, u1_32), sPt, s, sMt, t);

p384_ec_twin_mul : ([384], AffinePoint [384], [384], AffinePoint [384]) -> (JacobianPoint [384]);
p384_ec_twin_mul(x,p,y,q) = ec_twin_mul(p384_point_ops, x, p, y, q);

/* Return d0 * S + d1 * T. All points projective, 0 <= d0, d1 < p. */
ec_twin_mul : {fv gv} (fin gv, gv >= 4) 
            => (PointOps (fv,[gv]), [gv], AffinePoint fv, [gv], AffinePoint fv)
            -> (JacobianPoint fv);
ec_twin_mul(m, d0, s, d1, t) =
  if ec_is_zero_point(f, sPtP) then /* s + t = 0 */
    ec_mul(m, g.sub(d0, d1), s)
  else if ec_is_zero_point(f, sMtP) then /* s = t */
    ec_mul(m, g.add(d0, d1), s)
  else
    r!0

 where {
   f    = m.field;
   g    = m.group_field;
   sP   = ec_projectify(f, s);
   sPtP = m.add(sP, t); /* 1: ec_full_add (SpT, S, T) */
   sMtP = m.sub(sP, t); /* 2: ec_full_sub (SmT, S, T) */
   sDiv = f.div(f.field_unit, f.mul(sPtP.z, sMtP.z));
   sPt  = { x = f.mul(g2, sPtP.x); y = f.mul(f.mul(g, g2), sPtP.y); } where { g = f.mul(sMtP.z, sDiv); g2 = f.sq(g) };
   sMt  = { x = f.mul(g2, sMtP.x); y = f.mul(f.mul(g, g2), sMtP.y); } where { g = f.mul(sPtP.z, sDiv); g2 = f.sq(g) };
   F : [5] -> [5];
   F(t) = if (18 <= t) & (t < 22) then
            9
          else if (14 <= t) & (t < 18) then
            10
          else if (22 <= t) & (t < 24) then
            11
          else if (4 <= t) & (t < 12) then
            14
          else
            12;
   c = [[(zero # take(4, reverse(d0)))
         (zero # take(4, reverse(d1)))]]
     # [| [[(abs(u0) ^ c01) c02 c03 c04 c05 e0N]
           [(abs(u1) ^ c11) c12 c13 c14 c15 e1N]]
          where {
            abs : {a} (fin a) => [a] -> Bit;
            abs(x) = x != zero;
          }
       || [[c00 c01 c02 c03 c04 c05] [c10 c11 c12 c13 c14 c15]] <- c 
       || [u0 u1] <- u
       || e0N <- drop(4, reverse(d0)) # (zero : [4])
       || e1N <- drop(4, reverse(d1)) # (zero : [4])
       |];
   u = [| [u0 u1]
            where {
              h0' = [c05 c04 c03 c02 c01];
              h0 = if c00 then 31 - h0' else h0';
              h1' = [c15 c14 c13 c12 c11];
              h1 = if c10 then 31 - h1' else h1';
              u0 : [2];
              u0 = if h0 < F(h1) then 0 else if c00 then -1 else 1;
              u1 : [2];
              u1 = if h1 < F(h0) then 0 else if c10 then -1 else 1;
            }
       || [[c00 c01 c02 c03 c04 c05] [c10 c11 c12 c13 c14 c15]] <- c 
       |];
   r = [(ec_zero_point f)]
     # [| ec_twin_mul_aux1(m, rP, u0, u1, sPt, s, sMt, t)
       || rP      <- r
       || [u0 u1] <- u
       |];
 };

test_params : ([384], AffinePoint [384], [384], AffinePoint [384]) ;
test_params = 
//  (0x7b52dc21312701d79a2465bb9fdf6fd30c4f76cf74787e44348f8217e6ffd5e02ee8c55a7c5d91b452825b1026d26893, {x=0xdf1c86a62d76090308a0d4c371704b36f3bfa41f0dbf8185d297b8a2c811756f0f4be19871cde079c5d43cfd0fab7fe8; y=0x70521fdd9165b0d33e948be941c590f2fbe7e2754ba110ae24089d41773acfdd34701acaafa669a884d3eefbf557d98b}, 0x211bb4730ad83e31aedbd66a5a750e800cf4de096495323ea94a73f25e9bcb5068a9dcc93e98efecb136eb057e6f41a4, {x=0x6bdf86d8f4cdf5b63a6a1e93a75457c0816fa2f3f69bc706ab69a7b5a63d4956d83cc4ca551f6aaf7653b8dd0991a6af; y=0xa8ce019e78abd658350e5885c8fddb172117a24bf157dfdbe8a1831e03758e630784470287c8e25908d931f22581bf97});
//  (0x6250471849e0c0eb47e9cf2c8e04c9ad0745e358d1cf11fb53e178a3c5b301b5f9e7f62e61c8f2113615cc4ff9927f9b, {x=0x005255b811499293ea986c66b4698e0748284d391130afd3f9febbc71ef3b39fe13a3deaa1489d817b885edf270b1bf6; y=0xc9a1dcdb74a4ae432edea47750d754d918b2f1fd8d9ee612b4f0cf2bebcb0eeef43ef5d0ce90cb75362bd2cfe69bffad}, 0xd9e8d87abffb84c0c06fe47396aa84871f08420561a7d8cc64fef7796fc0ca9a5406a37a054cc8cd57e26a3a7249fdb3, {x=0x8da95367d9e731f86adda9bfae6ff170cf090be5223f3b33c0d7c6c585bfc1330137d237fdc16bd432797a1da1dfa331; y=0x114d8b24d75d0149603aa6eab6ccec1cd83f5baaca7898dd6edd7c2ca91176893102b9fe129a09f9fdb208e18be46d16});
  (0xe74872524f90425d832a4f264e1f7b9209ec7456e9b4c467d8eac6c68f973ea7fea24f4d3fa8498bb1e26f933eaa261b, {x=0xbbab93c429707b2afe9ac285314d7b40c4ee31531b13291aa9058307cdd038b572fdf2f3a84dc912804fa426fe531a3c; y=0x4c2cffaa333bfd82b575918bb979bf51480c836082c097a03fed5454877b37d2f44f0401d212c16b05052bd383047b31}, 0xd4356773f2b311955542c5835696b9dca9d0e59197d5746bbf7dc079a666d955f74114662e38d31196bf94b060cc0c80, {x=0xd40c63c65b413d0741c56e884f0dca63b822a6f6879d36f9261d9b4a270d5d79a9be790fdfb871b5d6ae9204da692663; y=0x4d6b2b937c85b3c0c3cd2df85e9307cc89e0093f336af3b4531aa126bbdbec466562d8aa0dc1cf360fc1f1d0951e3ad1});

theorem p384_ec_twin_mul_candidate2_ok: {x p y q}. ok1 & ok2 & ok3 where (_, ok1, ok2, ok3) = p384_ec_twin_mul_candidate2(x,p,y,q);
// theorem p384_ec_twin_mul_candidate2_good: {x p y q}. p384_ec_twin_mul(x,p,y,q) == p384_ec_twin_mul_candidate2(x,p,y,q);

// F : [5] -> [5] via original impl
// F : [32] -> [32] via fused impl

p384_ec_twin_mul_aux_F : {a} (fin a, a>=5) => [a] -> [a];
p384_ec_twin_mul_aux_F(t) = 
  if (18 <= t) & (t < 22) then
    9
  else if (14 <= t) & (t < 18) then
    10
  else if (22 <= t) & (t < 24) then
    11
  else if (4 <= t) & (t < 12) then
    14
  else
    12;

type TwinMulAux2Rslt = { tma2_h0 : [32]; tma2_h1 : [32]; tma2_c00 : Bit; tma2_c10 : Bit };
p384_ec_twin_mul_aux2 : ([32],[32]) -> TwinMulAux2Rslt;
p384_ec_twin_mul_aux2 (c0,c1) = { tma2_h0 = h0; tma2_h1 = h1; tma2_c00 = c00; tma2_c10 = c10 }
  where { 
    h0' = [c05 c04 c03 c02 c01];
    h0  = uext (if c00 then 31 - h0' else h0') : [32];
    h1' = [c15 c14 c13 c12 c11];
    h1  = uext (if c10 then 31 - h1' else h1') : [32];
    [c00 c01 c02 c03 c04 c05] = take(6, c0);
    [c10 c11 c12 c13 c14 c15] = take(6, c1);
  };

p384_ec_twin_mul_init :
  ([384], {x : [384];  y : [384]}, [384], {x : [384];  y : [384]}) ->
  { r : {x : [384]; y : [384]; z : [384]};
    sMt : {x : [384];  y : [384]};
    sPt : {x : [384];  y : [384]};
    special : Bit };
p384_ec_twin_mul_init(d0, s, d1, t) = {
    r = r0;
    special = special0;
    sPt = sPt0;
    sMt = sMt0;
  }
  where {
    (r0, special0) =
      if ec_is_zero_point(f, sPtP) then /* s + t = 0 */
        (p384_ec_mul(g.sub(d0, d1), s), True)
      else if ec_is_zero_point(f, sMtP) then /* s = t */
        (p384_ec_mul(g.add(d0, d1), s), True)
      else
        (zero, False);
    m    = p384_point_ops;
    f    = m.field;
    g    = m.group_field;
    sP   = ec_projectify(f, s);
    sPtP = m.add(sP, t); /* 1: ec_full_add (SpT, S, T) */
    sMtP = m.sub(sP, t); /* 2: ec_full_sub (SmT, S, T) */
    sDiv = f.div(f.field_unit, f.mul(sPtP.z, sMtP.z));
    sPt0 = { x = f.mul(g2, sPtP.x); y = f.mul(f.mul(g, g2), sPtP.y); }
           where { g = f.mul(sMtP.z, sDiv); g2 = f.sq(g) };
    sMt0 = { x = f.mul(g2, sMtP.x); y = f.mul(f.mul(g, g2), sMtP.y); }
           where { g = f.mul(sPtP.z, sDiv); g2 = f.sq(g) };
  };

p384_ec_twin_mul_candidate2(d0, s, d1, t) =
  (
    if i.special then i.r else r!0
  
/*
 , rf_cs == jj_cs
 , rf_us == jj_us
 , r!0   == jj_r where (jj_r, _, _, _, _, _, _) = jj!0
*/
//  , (rf_cs, jj_cs)
//  , (rf_us, jj_us)
  , rf_cs == jj_cs
  , rf_us == jj_us
  , r!0   == jj_r where (jj_r, _, _, _, _, _, _) = jj!0
  )
 where {
   m    = p384_point_ops;
   f    = m.field;
   g    = m.group_field;
   i    = p384_ec_twin_mul_init(d0, s, d1, t);

   c = [[(zero # take(4, reverse(d0)))
         (zero # take(4, reverse(d1)))]]
     # [| [[(abs(u0) ^ c01) c02 c03 c04 c05 e0N]
           [(abs(u1) ^ c11) c12 c13 c14 c15 e1N]]
          where {
            abs : {a} (fin a) => [a] -> Bit;
            abs(x) = x != zero;
          }
       || [[c00 c01 c02 c03 c04 c05] [c10 c11 c12 c13 c14 c15]] <- c 
       || [u0 u1] <- u
       || e0N <- drop(4, reverse(d0)) # (zero : [4])
       || e1N <- drop(4, reverse(d1)) # (zero : [4])
       |];
   u = [| [u0 u1]
            where {
              h0' = [c05 c04 c03 c02 c01];
              h0 = if c00 then 31 - h0' else h0';
              h1' = [c15 c14 c13 c12 c11];
              h1 = if c10 then 31 - h1' else h1';
              u0 : [2];
              u0 = if h0 < p384_ec_twin_mul_aux_F(h1) then 0 else if c00 then -1 else 1;
              u1 : [2];
              u1 = if h1 < p384_ec_twin_mul_aux_F(h0) then 0 else if c10 then -1 else 1;
            }
       || [[c00 c01 c02 c03 c04 c05] [c10 c11 c12 c13 c14 c15]] <- c 
       |];
   r = [(ec_zero_point f)]
     # [| ec_twin_mul_aux1(m, rP, u0, u1, i.sPt, s, i.sMt, t)
       || rP      <- r
       || [u0 u1] <- u
       |];

   // -- vvv fused implementation vvv -- 

   look_at = 385;
   rf_cs = join (take (look_at, [| [(uext c0 : [32]) (uext c1 : [32])] || [c0 c1] <- c |]));
   jj_cs = join (take (look_at, [| [c0 c1] || (_, c0, c1, _, _, _, _) <- take(385, jj) |]));
   rf_us = join (take (look_at, [| [(iext u0 : [32]) (iext u1 : [32])] || [u0 u1] <- u |]));
   jj_us = join (take (look_at, [| [u0 u1] || (_, _, _, u0, u1, _, _) <- take(385, jj) |]));

   compute_us : ([32],[32]) -> ([32],[32]);
   compute_us(c0,c1) = ( if h0 < p384_ec_twin_mul_aux_F(h1) then zero else if c00 then -1 else 1
                       , if h1 < p384_ec_twin_mul_aux_F(h0) then zero else if c10 then -1 else 1
                       ) 
                       where {
                         tma2r = p384_ec_twin_mul_aux2(c0, c1);
                         h0    = tma2r.tma2_h0;
                         h1    = tma2r.tma2_h1;
                         c00   = tma2r.tma2_c00;
                         c10   = tma2r.tma2_c10;

/*
                         h0' = [c05 c04 c03 c02 c01];
                         h0  = uext (if c00 then 31 - h0' else h0') : [32];
                         h1' = [c15 c14 c13 c12 c11];
                         h1  = uext (if c10 then 31 - h1' else h1') : [32];
                         [c00 c01 c02 c03 c04 c05] = take(6, c0);
                         [c10 c11 c12 c13 c14 c15] = take(6, c1);
*/
                        };

   c0_init            = uext ((zero # take(4, reverse(d0))) : [6]) : [32];
   c1_init            = uext ((zero # take(4, reverse(d1))) : [6]) : [32];
   (u0_init, u1_init) = compute_us(c0_init, c1_init);

   jj = [ ( ec_zero_point f
          , c0_init
          , c1_init
          , u0_init
          , u1_init
          , (drop(4, reverse(d0)) # (zero : [4]))
          , (drop(4, reverse(d1)) # (zero : [4]))
          )
        ]
      # [| ( ec_twin_mul_aux1(m, r, take(2, u0), take(2, u1), i.sPt, s, i.sMt, t)
           , c0'
           , c1'
           , u0'
           , u1'
           , drop(1, e0_bits) # zero
           , drop(1, e1_bits) # zero
           )
           where { 
            (u0', u1') = compute_us(c0', c1');
            c0'        = ((uext [(abs(u0) ^ c01) c02 c03 c04 c05 e0N]) : [32])
                         where { 
                           [c00 c01 c02 c03 c04 c05] = take(6, c0);
                           e0N = 1 == take(1, e0_bits);
                         };
            c1'        = ((uext [(abs(u1) ^ c11) c12 c13 c14 c15 e1N]) : [32])
                         where {
                           [c10 c11 c12 c13 c14 c15] = take(6, c1);
                           e1N = 1 == take(1, e1_bits);
                         };
            abs : {a} (fin a) => [a] -> Bit;
            abs(x) = x != zero;
           }
        || (r, c0, c1, u0, u1, e0_bits, e1_bits) <- jj
        || k <- reverse [(-5:[32]) .. 379]
        |];

 };

theorem ec_twin_mul_with_aux1_ok : {x p y q}. 
  ec_twin_mul_orig(p384_point_ops, x, p, y, q) == p384_ec_twin_mul(x, p, y, q);

/* Return d0 * S + d1 * T. All points projective, 0 <= d0, d1 < p. */
ec_twin_mul_orig : {fv gv} (fin gv, gv >= 4) 
                  => (PointOps (fv,[gv]), [gv], AffinePoint fv, [gv], AffinePoint fv)
                  -> (JacobianPoint fv);
ec_twin_mul_orig(m, d0, s, d1, t) =
  if ec_is_zero_point(f, sPtP) then /* s + t = 0 */
    ec_mul(m, g.sub(d0, d1), s)
  else if ec_is_zero_point(f, sMtP) then /* s = t */
    ec_mul(m, g.add(d0, d1), s)
  else
    r!0
 where {
   f = m.field;
   g = m.group_field;
   sP = ec_projectify(f, s);
   sPtP = m.add(sP, t); /* 1: ec_full_add (SpT, S, T) */
   sMtP = m.sub(sP, t); /* 2: ec_full_sub (SmT, S, T) */
   sDiv = f.div(f.field_unit, f.mul(sPtP.z, sMtP.z));
   sPt = { x = f.mul(g2, sPtP.x); y = f.mul(f.mul(g, g2), sPtP.y); }
    where { g = f.mul(sMtP.z, sDiv); g2 = f.sq(g) };
   sMt = { x = f.mul(g2, sMtP.x); y = f.mul(f.mul(g, g2), sMtP.y); }
    where { g = f.mul(sPtP.z, sDiv); g2 = f.sq(g) };
   F : [5] -> [5];
   F(t) = if (18 <= t) & (t < 22) then
            9
          else if (14 <= t) & (t < 18) then
            10
          else if (22 <= t) & (t < 24) then
            11
          else if (4 <= t) & (t < 12) then
            14
          else
            12;
   c = [[(zero # take(4, reverse(d0)))
         (zero # take(4, reverse(d1)))]]
     # [| [[(abs(u0) ^ c01) c02 c03 c04 c05 e0N]
           [(abs(u1) ^ c11) c12 c13 c14 c15 e1N]]
          where {
            abs : {a} (fin a) => [a] -> Bit;
            abs(x) = x != zero;
          }
       || [[c00 c01 c02 c03 c04 c05] [c10 c11 c12 c13 c14 c15]] <- c 
       || [u0 u1] <- u
       || e0N <- drop(4, reverse(d0)) # (zero : [4])
       || e1N <- drop(4, reverse(d1)) # (zero : [4])
       |];
   u = [| [u0 u1]
            where {
              h0' = [c05 c04 c03 c02 c01];
              h0 = if c00 then 31 - h0' else h0';
              h1' = [c15 c14 c13 c12 c11];
              h1 = if c10 then 31 - h1' else h1';
              u0 : [2];
              u0 = if h0 < F(h1) then 0 else if c00 then -1 else 1;
              u1 : [2];
              u1 = if h1 < F(h0) then 0 else if c10 then -1 else 1;
            }
       || [[c00 c01 c02 c03 c04 c05] [c10 c11 c12 c13 c14 c15]] <- c 
       |];
   r = [(ec_zero_point f)]
     # [| if      (u0 == -1) & (u1 == -1) then m.sub(r2, sPt)
          else if (u0 == -1) & (u1 ==  0) then m.sub(r2, s)
          else if (u0 == -1) & (u1 ==  1) then m.sub(r2, sMt)
          else if (u0 ==  0) & (u1 == -1) then m.sub(r2, t)
          else if (u0 ==  0) & (u1 ==  1) then m.add(r2, t)
          else if (u0 ==  1) & (u1 == -1) then m.add(r2, sMt)
          else if (u0 ==  1) & (u1 ==  0) then m.add(r2, s)
          else if (u0 ==  1) & (u1 ==  1) then m.add(r2, sPt)
          else r2
           where r2 = m.double(rP)
       || rP <- r
       || [u0 u1] <- u
       |];
 };

/* ECDSA Operations {{{1 */

/** Operations for ECDSA abstraction layer */
type Curve (fv,gv) = {
    point_ops : PointOps (fv,gv);
    base : AffinePoint fv;
    affinify : JacobianPoint fv -> AffinePoint fv;
    mul : (gv, AffinePoint fv) -> JacobianPoint fv;
    twin_mul : (gv, AffinePoint fv, gv, AffinePoint fv) -> JacobianPoint fv;
  };

/**
 * Reference ECDSA signature algorithm as formalized from [ANSI X9.62-2005, pg 8]
 * Parameters:
 *  Curve c
 *  Private key d of signatory.
 *  Integer e obtained after hashing message on step e)
 *  Ephemeral EC private key in range [1 .. c.curve)
 */
ecdsa_sign : {fv} (fin fv, fv >= 1) => (Curve ([fv],[fv]), [fv], [fv], [fv]) -> ([fv], [fv]);
ecdsa_sign(c,d,e,k) = if is_zero(r) | is_zero(s) then (0,0) else (r, s)
  where {
    g = c.point_ops.group_field;
    is_zero(x) = g.is_equal(x, g.field_zero);
    /* Compute x coordinate of public key. */
    j = (c.affinify(c.mul(k, c.base))).x;
    /* c) Set r = j mod n */
    r = g.norm(j);
    s = g.div(g.add(g.norm(e), g.mul(d, r)), k);
  };

/**
 * Reference ECDSA signature verification algorithm as formalized from [ANSI X9.62-2005, pg 9]
 * Parameters
 *  Curve c
 *  Integer e' obtained after hashing message on  step "c".
 *  Pair returned by ref_ecdsa_sign algorithm.
 *  Public key of key signatory.
 * Result:
 *  Bit that is True if verification suceeds, and false otherwise.
 */
ecdsa_public_verify : {fv} (fin fv, fv >= 1)
   => (Curve ([fv],[fv]), [fv], ([fv], [fv]), AffinePoint [fv]) -> Bit;
ecdsa_public_verify(c, e, (r, s), q)
    /* h) Compare v and r' if v = r', output "valid"; otherwise output "invalid". */
   = in_range(s) & (v == r)
  where {
    f = c.point_ops.field;
    g = c.point_ops.group_field;
    mul(x,y) = g.mul(x, y);
    div(x,y) = g.div(x, y);
    is_zero(x) = g.is_equal(x, g.field_zero);
    in_range(x) = ~is_zero(x) & g.is_val(x);
    s_inv = div(1, s);
    u1 = mul(e, s_inv);
    u2 = mul(r, s_inv);
    r2 = c.twin_mul(u1, c.base, u2, q);
    /* f) Convert the field element x_r to an integer j as described in A.5 */
    j = f.mul(r2.x, f.sq(f.div(f.field_unit, r2.z)));
    /* g) v = j mod n */
    v = g.norm(j);
  };

/* P384 reference definitions {{{1 */

/* Utility functions {{{2 */ 

type RsltWithCarry (a,b) = { carry : a ; rslt : b };

p384_incFieldPrime : [384] -> RsltWithCarry ([32],[384]);
p384_incFieldPrime x = {carry = [(bs ! 0)] # zero; rslt = take(384, bs)}
  where bs = safe_add(x, p384_prime);

p384_decFieldPrime : [384] -> RsltWithCarry ([32],[384]);
p384_decFieldPrime x = { carry = if (bs ! 0) then -1 else 0; rslt = take(384, bs)}
  where bs = safe_sub(x, p384_prime);

/* P384 modular arithmetic definitions. {{{2 */

p384_safe_product : ([384], [384]) -> [768];
p384_safe_product (x, y) = safe_product(x, y);

p384_mod_add : ([384],[384],[384]) -> [384];
p384_mod_add = mod_add;

p384_mod_sub : ([384],[384],[384]) -> [384];
p384_mod_sub = mod_sub;

p384_mod_mul : ([384],[384],[384]) -> [384];
p384_mod_mul = mod_mul;

p384_mod_half : ([384],[384]) -> [384];
p384_mod_half = mod_half;

p384_mod_div : ([384],[384],[384]) -> [384];
p384_mod_div = mod_div;

/* P384 field definitions. {{{2 */

p384_prime : [384];
p384_prime = - (2 ** 384 + 2 ** 128 + 2 ** 96 - 2 ** 32 + 1);

// P384 field reference modulus.
p384_field_mod : [768] -> [384];
p384_field_mod(a)
    = take(384,
            if b1 then r0
            else if b2 then r1
            else if b3 then r2
            else if b4 then r3
            else r4)
  where {
    p       = p384_prime # (zero : [32]);
    rwc     = p384_field_mod_aux(a);
    z       = rwc.rslt;
    d       = rwc.carry;
    r       = z # d;
    r0      = if (d!0) then r + p else r; // Fix potential underflow
    // Fix potential overflow
    (r1,b1) = sbb(r0, p);
    (r2,b2) = sbb(r1, p);
    (r3,b3) = sbb(r2, p);
    (r4,b4) = sbb(r3, p);
   };

p384_field_mod_aux : [768] -> RsltWithCarry ([32],[384]);
 p384_field_mod_aux(a) = 
  { carry = d11; 
    rslt  = z0 # z1 # z2 # z3 # z4 # z5 # z6 # z7 # z8 # z9 # z10 # z11 } 
  where {
    [ a0  a1  a2  a3  a4  a5  a6  a7  a8  a9 a10 a11
     a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23 ]
              = [| uext x || x <- (split a : [24][32]) |] : [24][64];
    chop x    = (take (32,x), drop(32, x));
    zd0       =             a0 + a12  + a21 + a20 - a23; 
    zd1       = iext(d0)  + a1 + a13 + a22 + a23 - a12 - a20;
    zd2       = iext(d1)  + a2 + a14 + a23 - a13 - a21;
    zd3       = iext(d2)  + a3 + a15 + a12 + a20 + a21 - a14 - a22 - a23;
    zd4       = iext(d3)  + a4 + (a21 << 1) + a16 + a13 + a12 + a20 + a22 - a15 - (a23 << 1);
    zd5       = iext(d4)  + a5 + (a22 << 1) + a17 + a14 + a13 + a21 + a23 - a16;
    zd6       = iext(d5)  + a6 + (a23 << 1) + a18 + a15 + a14 + a22 - a17;
    zd7       = iext(d6)  + a7 + a19 + a16 + a15 + a23 - a18;
    zd8       = iext(d7)  + a8 + a20 + a17 + a16 - a19;
    zd9       = iext(d8)  + a9 + a21 + a18 + a17 - a20;
    zd10      = iext(d9)  + a10 + a22 + a19 + a18 - a21;
    zd11      = iext(d10) + a11 + a23 + a20 + a19 - a22;
    (z0,d0)   = chop zd0;
    (z1,d1)   = chop zd1;
    (z2,d2)   = chop zd2;
    (z3,d3)   = chop zd3;
    (z4,d4)   = chop zd4;
    (z5,d5)   = chop zd5;
    (z6,d6)   = chop zd6;
    (z7,d7)   = chop zd7;
    (z8,d8)   = chop zd8;
    (z9,d9)   = chop zd9;
    (z10,d10) = chop zd10;
    (z11,d11) = chop zd11;
  };

/* ABC also discharges equivalence of Java's field_red against these two
   candidate functions, and does so fairly quickly.  However, the operation
   above is closer to the original specification, and ABC handles it within a
   few minutes, so we'll keep it as our primary reference implementation for
   field_red.  The original spec is found below as p384_field_mod_orig. */

p384_field_mod_candidate1 : [768] -> [384];
p384_field_mod_candidate1(a) = rslt
  where {
    p       = p384_prime # (zero : [32]);
    rwc     = p384_field_mod_aux(a);
    z       = rwc.rslt;
    d       = rwc.carry;
    r       = z # d;
    rslt    = if (d!0) 
                then t.rslt where { t = p384_incFieldPrime(z) }
                else p384_field_add(r', iext(of) * (2 ** 128 + 2 ** 96 - 2 ** 32 + 1))
              where {
                (r',of) = (take(384, r), drop(384, r));
              };
  };

p384_field_mod_candidate2 : [768] -> [384];
p384_field_mod_candidate2(a) = rslt
  where {
    rwc     = p384_field_mod_aux(a);
    z       = rwc.rslt;
    d       = rwc.carry;
    rslt    = if (d!0) 
                then (t.rslt where { t = p384_incFieldPrime(z) }
                     )
                else (if (d11 > 0) | (p384_prime <= z') then (p384_decFieldPrime(z')).rslt else z'
                     ) 
              where {
                of         = iext d;
                zd0        =              z0 + of;
                zd1        = iext (d0)  + z1 - of;
                zd2        = iext (d1)  + z2;
                zd3        = iext (d2)  + z3 + of;
                zd4        = iext (d3)  + z4 + of;
                zd5        = iext (d4)  + z5;
                zd6        = iext (d5)  + z6;
                zd7        = iext (d6)  + z7;
                zd8        = iext (d7)  + z8;
                zd9        = iext (d8)  + z9;
                zd10       = iext (d9)  + z10;
                zd11       = iext (d10) + z11;
                (z0',d0)   = chop zd0;
                (z1',d1)   = chop zd1;
                (z2',d2)   = chop zd2;
                (z3',d3)   = chop zd3;
                (z4',d4)   = chop zd4;
                (z5',d5)   = chop zd5;
                (z6',d6)   = chop zd6;
                (z7',d7)   = chop zd7;
                (z8',d8)   = chop zd8;
                (z9',d9)   = chop zd9;
                (z10',d10) = chop zd10;
                (z11',d11) = chop zd11;
                [z0 z1 z2 z3 z4 z5 z6 z7 z8 z9 z10 z11] 
                           = [| uext x || x <- split z |] : [12][64];
                z'         = join [ z0' z1' z2' z3' z4' z5' z6' z7' z8' z9' z10' z11' ] : [384];
              };
    chop x = (take (32,x), drop(32, x));
  };

p384_field_mod_orig : [768] -> [384];
p384_field_mod_orig(a)
    = take(384,
           if b1 then r 
           else if b2 then r1
           else if b3 then r2
           else if b4 then r3
           else r4)
  where {
    [ a0  a1  a2  a3  a4  a5  a6  a7  a8  a9 a10 a11
     a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23]
       = split a;
    z32 = zero : [32];
    z64 = zero : [64];
    p = p384_prime # z32;
    t  =  a0 #  a1 #  a2 #  a3 #  a4 #  a5 #  a6 #  a7 #  a8 #  a9 # a10 # a11 # z32;
    s1 =     (zero : [128])    # a21 # a22 # a23 #      (zero : [160])         # z32;
    s2 = a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # a21 # a22 # a23 # z32;
    s3 = a21 # a22 # a23 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # z32; 
    s4 = z32 # a23 # z32 # a20 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # z32;
    s5 =     (zero : [128])    # a20 # a21 # a22 # a23 #    (zero : [128])     # z32;
    s6 = a20 #    z64    # a21 # a22 # a23 #          (zero : [192])           # z32;
    d1 = a23 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # a21 # a22 # z32;
    d2 = z32 # a20 # a21 # a22 # a23 #              (zero : [224])             # z32;
    d3 =  (zero : [96])  # a23 # a23 #              (zero : [224])             # z32;
    d1' = p - d1;
    r = t + (s1 << 1) + s2 + s3 + s4 + s5 + s6 + d1' - d2 - d3;
    (r1,b1) = sbb(r, p);
    (r2,b2) = sbb(r1, p);
    (r3,b3) = sbb(r2, p);
    (r4,b4) = sbb(r3, p);
   };

p384_field_mod_aux_orig : [768] -> RsltWithCarry ([32],[384]);
p384_field_mod_aux_orig(a) = {carry = drop(384, r); rslt = take(384, r)}
  where {
    [ a0  a1  a2  a3  a4  a5  a6  a7  a8  a9 a10 a11
     a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23]
        = split a;
    z32 = zero : [32];
    z64 = zero : [64];
    p   = p384_prime # z32;
    t   =  a0 #  a1 #  a2 #  a3 #  a4 #  a5 #  a6 #  a7 #  a8 #  a9 # a10 # a11 # z32;
    s1  =     (zero : [128])    # a21 # a22 # a23 #      (zero : [160])         # z32;
    s2  = a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # a21 # a22 # a23 # z32;
    s3  = a21 # a22 # a23 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # z32; 
    s4  = z32 # a23 # z32 # a20 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # z32;
    s5  =     (zero : [128])    # a20 # a21 # a22 # a23 #    (zero : [128])     # z32;
    s6  = a20 #    z64    # a21 # a22 # a23 #          (zero : [192])           # z32;
    d1  = a23 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # a21 # a22 # z32;
    d2  = z32 # a20 # a21 # a22 # a23 #              (zero : [224])             # z32;
    d3  =  (zero : [96])  # a23 # a23 #              (zero : [224])             # z32;
    r   = t + (s1 << 1) + s2 + s3 + s4 + s5 + s6 - d1 - d2 - d3;
  };
  
theorem p384_field_mod_aux_same_as_orig : {x}. p384_field_mod_aux_orig(x) == p384_field_mod_aux(x);
theorem p384_field_mod_with_aux_ok      : {x}. p384_field_mod_orig(x) == p384_field_mod(x);

// Give explicit names to these finite field operators, so SBV
//  can uninterpret them.
p384_is_field_val  = is_normal p384_prime;

p384_field_add(x,y) = p384_mod_add(p384_prime, x, y);
p384_field_sub(x,y) = p384_mod_sub(p384_prime, x, y);
/* p384_field_neg(x) returns -x mod p384_prime. */
p384_field_neg(x)        = if x == 0 then 0 else (p384_prime - x);

p384_field_mul : ([384],[384]) -> [384];
p384_field_mul(x,y)      = p384_field_mod(p384_safe_product(x, y));

p384_field_sq(x)         = p384_field_mul(x, x);
p384_field_cube(x)       = p384_field_mul(x, p384_field_sq(x));


/* Defines a reference prime field that uses normalized numbers and
   large word bit operations. */
p384_field :  Field [384];
p384_field = {
    is_val     = p384_is_field_val;
    norm       = \x -> if x < p384_prime then x else x - p384_prime;
    add        = p384_field_add;
    sub        = p384_field_sub;
    neg        = p384_field_neg;
    mul        = p384_field_mul;
    sq         = p384_field_sq;
    half       = \x -> p384_mod_half(p384_prime, x);
    div        = \(x,y) -> p384_mod_div(p384_prime, x, y);
    field_zero = 0;
    field_unit = 1;
    is_equal   = \(x,y) -> x == y;
    };

/* P384 group field operations {{{2 */

p384_group_size : [384];
p384_group_size =
  join(reverse 
    [0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff
     0xc7634d81 0xf4372ddf 0x581a0db2 0x48b0a77a 0xecec196a 0xccc52973]);

/* Defines a reference prime field that uses normalized numbers and
   large word bit operations. */
p384_group_field :  Field [384];
p384_group_field = {
    is_val     = is_normal p384_group_size;
    norm       = \x -> if x < p384_group_size then x else x - p384_group_size;
    add        = \(x,y) -> p384_mod_add(p384_group_size, x, y);
    sub        = \(x,y) -> p384_mod_sub(p384_group_size, x, y);
    neg        = \x     -> mod_neg(p384_group_size, x);
    mul        = \(x,y) -> p384_mod_mul(p384_group_size, x, y);
    sq         = \x     -> mod_mul(p384_group_size, x, x);
    half       = \x     -> mod_half(p384_group_size, x);
    div        = \(x,y) -> p384_mod_div(p384_group_size, x, y);
    field_zero = 0;
    field_unit = 1;
    is_equal   = \(x,y) -> x == y;
    };

/** P384 curve operations {{{2 */

p384_base : AffinePoint [384];
p384_base = nzAffinePoint(
  join(reverse
       [0xaa87ca22 0xbe8b0537 0x8eb1c71e 0xf320ad74 0x6e1d3b62 0x8ba79b98
        0x59f741e0 0x82542a38 0x5502f25d 0xbf55296c 0x3a545e38 0x72760ab7]),
  join(reverse
       [0x3617de4a 0x96262c6f 0x5d9e98bf 0x9292dc29 0xf8f41dbd 0x289a147c
        0xe9da3113 0xb5f0b8c0 0x0a60b1ce 0x1d7e819d 0x7a431d7c 0x90ea0e5f]));

p384_ec_zero_point : JacobianPoint [384];
p384_ec_zero_point = ec_zero_point(p384_field);

p384_ec_double : JacobianPoint [384] -> JacobianPoint [384];
p384_ec_double(p) = ec_double(p384_field, p);

p384_ec_full_add : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384];

p384_ec_full_sub : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384];

p384_point_ops : PointOps ([384],[384]);
p384_point_ops = {
    field = p384_field;
    double = p384_ec_double;
    add = p384_ec_full_add;
    sub = p384_ec_full_sub;
    group_field = p384_group_field;
  };

p384_ec_full_add(p,q) = ec_full_add(p384_point_ops, p, q);
p384_ec_full_sub(p,q) = ec_full_sub(p384_point_ops, p, q);

java_ishl : ([32],[32]) -> [32];
java_ishl (x,s) = x << (s & 0x1f);

/* Matches Java implementation */
p384_ec_mul_aux : ( JacobianPoint [384]
                   , AffinePoint [384]
                   , [32], [32], [32], [32], [32] ) -> JacobianPoint [384];
p384_ec_mul_aux (r, s, j, hi, i_lt_11, d_at_i, d_at_ip1) = r'
  where {
    m   = java_ishl(1, j);
    ki  = d_at_i >> 1;
    ki' = if i_lt_11 != 0 then ki | ((d_at_ip1 & 1) << 31) else ki;
    r'' = p384_ec_double(r);
    r'  = if ((hi & m) != zero) & ((ki' & m) == zero) then
            p384_ec_full_add(r'', s)
          else if ((hi & m) == zero) & ((ki' & m) != zero) then
            p384_ec_full_sub(r'', s)
          else r'';
  };

p384_ec_mul_init : ([384], AffinePoint [384]) ->
                   { h: [384]; r: JacobianPoint [384]; };
p384_ec_mul_init (d, s) = { h = join h0; r = r0 }
  where {
    d' : [12][32];
    d' = split d;
    (h0, c) = ripple_adc(d', ripple_shr(d', False));
    r0 = if c then ec_projectify(p384_field, s)
              else p384_ec_zero_point;
  };

/* Matches Java implementation */
p384_ec_mul : ([384], AffinePoint [384]) -> JacobianPoint [384];
p384_ec_mul (d, s) = (res @ 384)
  where {
    d' : [12][32];
    d' = split d;
    ini =  p384_ec_mul_init(d, s);
    h : [12][32];
    h = split (ini.h);
    r0 = ini.r;
    f (j, r) = p384_ec_mul_aux(r, s, j, h @ i, [c] # zero, d'@i, d_at_ip1)
      where {
        i        = j >> 5;
        c        = i < 11;
        d_at_ip1 = if c then d'@(i+1) else 0; 
                   /* NB: We guard indexing here to avoid bounds VCs;
                      p384_ec_mul_aux's use of d_at_ip1 is likewise
                      guarded. */
      };
    res = [r0] #
          [| f(j, r)
          || j <- mk_strm (reverse [0..383])
          || r <- res
          |]
  };

/*
p384_ec_mul_aux : ( JacobianPoint [384]
                   , AffinePoint [384]
                   , [32], [32], [32] ) -> JacobianPoint [384];
p384_ec_mul_aux (r, s, m, hi, ki) = r'
  where {
    r'' = p384_ec_double(r);
    r' = if ((hi & m) != zero) & ((ki & m) == zero) then
           p384_ec_full_add(r'', s)
         else if ((hi & m) == zero) & ((ki & m) != zero) then
           p384_ec_full_sub(r'', s)
         else r'';
  };
*/

/*
p384_ec_mul (d, s) = (res @ 384)
  where {
    d' : [12][32];
    d' = split d;
    (h, c) = ripple_adc(d', ripple_shr(d', False));
    r0 = if c
          then ec_projectify(p384_field, s)
          else p384_ec_zero_point;
    f (j, r) = p384_ec_mul_aux(r, s, 1 << j, h @ i, ki')
      where {
        i = j >> 5;
        ki = (d' @ i) >> 1;
        ki' = if i < 11 then ki | (((d' @ (i+1)) & 1) << 31) else ki;
      };
    res = [r0] #
          [| f(j, r)
          || j <- mk_strm (reverse [0..383])
          || r <- res
          |]
  };
*/

p384_group_add : ([384],[384]) -> [384];
p384_group_add = p384_group_field.add;

p384_curve : Curve ([384],[384]);
p384_curve = {
    point_ops = p384_point_ops;
    base = p384_base;
    affinify = \x -> ec_affinify(p384_field, x);
    mul = p384_ec_mul;
    twin_mul = p384_ec_twin_mul;
  };

p384_ecdsa_sign : ([384], [384], [384]) -> { r:[384]; s:[384] };
p384_ecdsa_sign(d,e,k) = { r = rr; s = ss }
  where (rr, ss) = ecdsa_sign(p384_curve,d,e,k);

p384_ecdsa_public_verify : ([384], [384], [384], AffinePoint [384]) -> Bit;
p384_ecdsa_public_verify(e,pr,ps,q) = ecdsa_public_verify(p384_curve,e,(pr,ps),q);

/* P384 test code {{{2 */

/* Curve "a" parameter, defined in [FIPS-186-3, page 87] to be -3 */
p384_a : [384];
p384_a = p384_prime - 3;

/* Curve "b" parameter, defined in [FIPS-186-3, page 89] */
p384_b : [384];
p384_b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef;

/* Point "S" defined in [NSA 2008, Section 4.4.2] */
p384_s : AffinePoint [384];
p384_s = nzAffinePoint(
  join(reverse
        [0xfba203b8 0x1bbd23f2 0xb3be971c 0xc23997e1 0xae4d89e6 0x9cb6f923
         0x85dda827 0x68ada415 0xebab4167 0x459da98e 0x62b1332d 0x1e73cb0e]),
  join(reverse
        [0x5ffedbae 0xfdeba603 0xe7923e06 0xcdb5d0c6 0x5b223014 0x29293376
         0xd5c6944e 0x3fa6259f 0x162b4788 0xde6987fd 0x59aed5e4 0xb5285e45]));

/* Point "T" defined in [NSA 2008, Section 4.4.2] */
p384_t : AffinePoint [384];
p384_t = nzAffinePoint(
  join(reverse
        [0xaacc0520 0x2e7fda6f 0xc73d82f0 0xa6622052 0x7da8117e 0xe8f8330e
         0xad7d20ee 0x6f255f58 0x2d8bd38c 0x5a7f2b40 0xbcdb68ba 0x13d81051]),
  join(reverse
        [0x84009a26 0x3fefba7c 0x2c57cffa 0x5db3634d 0x286131af 0xc0fca8d2
         0x5afa22a7 0xb5dce0d9 0x470da892 0x33cee178 0x592f49b6 0xfecb5092]));

/* Multiple "D" defined in [NSA 2008, Section 4.4.2] */
p384_d =
  join(reverse
        [0xa4ebcae5 0xa6659834 0x93ab3e62 0x6085a24c 0x104311a7 0x61b5a8fd
         0xac052ed1 0xf111a5c4 0x4f76f456 0x59d2d111 0xa61b5fdd 0x97583480]);

/* Multiple "E" defined in [NSA 2008, Section 4.4.2] */
p384_e =
  join(reverse
        [0xafcf8811 0x9a3a76c8 0x7acbd600 0x8e1349b2 0x9f4ba9aa 0x0e12ce89
         0xbcfcae21 0x80b38d81 0xab8cf150 0x95301a18 0x2afbc689 0x3e75385d]);

/* Convert a p384 Jacobian point to an affine point */
p384_affinify : JacobianPoint [384] -> AffinePoint [384];
p384_affinify p = ec_affinify(p384_field, p);

/* Convert a p384 affine point to a Jacobian point */
p384_jacobify : AffinePoint [384] -> JacobianPoint [384];
p384_jacobify p = { x = p.x; y = p.y; z = 1 };

p384_base4 : JacobianPoint [384];
p384_base4 = p384_ec_double(p384_ec_double(p384_jacobify(p384_base)));

p384_base3 : AffinePoint [384];
p384_base3 = p384_affinify(p384_ec_full_sub(p384_base4, p384_base));

p384_base5 : AffinePoint [384];
p384_base5 = p384_affinify(p384_ec_full_add(p384_base4, p384_base));


/* Does an affine point lie on the curve? */
p384_is_affine_point : AffinePoint [384] -> Bit;
p384_is_affine_point p =
  p384_field_sq(p.y) ==
  p384_field_add(p384_field_cube(p.x),
                 p384_field_add(p384_field_mul(p384_a, p.x), p384_b));

/* P384 implementation curve definition {{{1 */

/* Chunked arithmetic routines {{{2 */

/* Promote a finite sequence to an infinite sequence */
mk_strm : {a b} fin a => [a][b] -> [inf][b];
mk_strm x = x # zero;

/* Adds two n*m bit numbers split into m-bit segments and returns carry. */
ripple_adc : {m  n} (m >= 1, fin m, fin n) => ([n][m],[n][m]) -> ([n][m],Bit);
ripple_adc(xx,yy) = (values, carry_strm @ (width xx))
  where {
    adc(x,y,c) = (take(width x,sum), sum @ width x)
      where sum = safe_add(x,y) + uext([c]);
    list_strm = [| adc(a,b,c)
           || a <- mk_strm xx
           || b <- mk_strm yy
           || c <- carry_strm
           |];
    list = take(width xx,list_strm);
    values = [| v || (v,_) <- list |];
    carry_strm  = [False] # [| c || (_,c) <- list_strm |];
  };

/* Returns (xl # c) >> 1. */
ripple_shr : {m n} (m >= 1, fin m, n >= 1, fin n) => ([n][m],Bit) -> ([n][m]);
ripple_shr(xl,c) = [| (x' << (width(x) - 1)) | (x >> 1)
                   || x <- xl
                   || x' <- drop(1,xl) # [(uext([c]))] |];
