include "Field.cry"; /* Defines Field type and generic operations */

/* Core bit-level operations. {{{1 */

/* Unsigned word extension. */
uext : {a b} (b >= a, fin a) => [a] -> [b];
uext(x) = x # zero;

iext : {a b} (b >= a, fin a) => [a] -> [b];
iext(x) = x # (if x!0 then ~zero else zero);

/* Returns the (n+1)-bit sum of two n-bit numbers. */
safe_add : {n} (fin n) => ([n],[n]) -> [n+1];
safe_add(x,y) = uext(x) + uext(y);

/* returns the (n+1)-bit subtraction of two n-bit numbers. */
safe_sub : {n} (fin n) => ([n],[n]) -> [n+1];
safe_sub(x,y) = uext(x) - uext(y);

/* Is x in normalized form (relative to prime p)? */
is_normal : {a} (fin a) => [a] -> [a] -> Bit;
is_normal p x = (x < p);

/* Returns the product of two inputs. */
safe_product : {a} (fin a) => ([a],[a]) -> [2*a];
safe_product(x,y) = uext(x) * uext(y);

/* Returns module reduction on input. */
safe_mod : {a b} (fin a, fin b) => ([b],[a]) -> [b];
safe_mod(p,x) = take(width(p), (x # zero) % (p # zero));

/* Add two n-bit numbers and input carry to obtain a n bit number and output carry. */
adc : {n} (fin n) => ([n],[n]) -> ([n],Bit);
adc(x,y) = (take(width x,sum), sum @ width x)
  where sum = safe_add(x,y);

/* sbb(x,y) subtracts y from x, and returns result along with output borrow bit. */
sbb : {n} (fin n) => ([n],[n]) -> ([n],Bit);
sbb(x,y) = (take(width x, r), ~(r ! 0))
  where r = (x # [True]) - (y # [False]);

/* Field primitives common to group and underlying field. {{{1 */

/* Add two numbers in normalized form. */
mod_add : {n} (fin n) => ([n],[n],[n]) -> [n];
mod_add(p,x,y) = if c1 | ~c2 then r2 else r1
  where {
    (r1,c1) = adc( x, y);
    (r2,c2) = sbb(r1, p);
  };

/* Subtract two numbers in normalized form. */
mod_sub : {n} (fin n) => ([n],[n],[n]) -> [n];
mod_sub(p,x,y) = if b then r2 else r1
  where {
    (r1,b) = sbb( x, y);
    (r2,_) = adc(r1, p);
  };

mod_neg : {n} (fin n) => ([n],[n]) -> [n];
mod_neg(p,x) = if x == 0 then 0 else (p - x);

mod_half : {n} (fin n, n >= 1) => ([n],[n]) -> [n];
mod_half(p, x) = if even(x) then x >> 1
                 else drop(1, safe_add(x, p))
  where { even x = (x & 1) == 0; };

/* Definition of modular multiplication. */
mod_mul : {n} (fin n) => ([n],[n],[n]) -> [n];
mod_mul(p,x,y) = safe_mod(p, safe_product(x, y));

/* Returns x/y in F_p using Euler's binary gcd algorithm. */
/* Taken from [HMV] */
mod_div : {a} (fin a, a >= 1) => ([a],[a],[a]) -> [a];
mod_div(p,x,y) = egcd(p,0,y,x)
  where {
    /* In code below, a is always odd. */
    egcd(a,ra,b,rb) =
      if b == 0 then
        ra
      else if (b & 1) == 0 then /* b is even. */
        egcd(a, ra, b >> 1, mod_half(p, rb))
      else if a < b then
        egcd(a, ra, (b - a) >> 1, mod_half(p, mod_sub(p, rb, ra)))
      else 
        egcd(b, rb, (a - b) >> 1, mod_half(p, mod_sub(p, ra, rb)));
    pragma egcd: ISABELLE skipTerminationProof;
  };

/* Point operations {{{1 */

type AffinePoint fv = { x : fv; y : fv; };

/* Return an affine point. */
nzAffinePoint : {fv} (fv,fv) -> AffinePoint fv;
nzAffinePoint (ax,ay) = { x = ax; y = ay };

/* Define Jacobian points */
type JacobianPoint fv = { x : fv; y : fv; z : fv; };

/* Create affine point from Jacobian (only well-defined if z coordinate is non-zero). */
ec_affinify : {fv} (Field fv, JacobianPoint fv) -> AffinePoint fv;
ec_affinify(f,s) = { x = f.mul(g2, s.x); y = f.mul(g3, s.y); }
  where { g = f.div(f.field_unit, s.z); g2 = f.sq(g); g3 = f.mul(g, g2); };

/* Create projective value from affine. */
/* Routine 2.2.1 in [NSA 2008] */
ec_projectify : {fv} (Field fv, AffinePoint fv) -> JacobianPoint fv;
ec_projectify(f,s) = { x = s.x; y = s.y; z = f.field_unit };

/* Returns zero point. */
ec_zero_point : {fv} Field fv -> JacobianPoint fv;
ec_zero_point(f) = { x = f.field_unit; y = f.field_unit; z = f.field_zero };

/* Checks to see if point is zero. */
ec_is_zero_point : {fv} (Field fv, JacobianPoint fv) -> Bit;
ec_is_zero_point(f,s) = f.is_equal(s.z, f.field_zero);

/* Is the Jacobian point well-formed? Here we assume
** the only valid zero-point is the unit zero point.
** NOTE: The output of ECC operations in this file always
**   satisfies this assumption. However, they are more
**   permissive in their inputs, i.e. they still do the
**   right thing when given a non-unit zero point.
*/
is_JacobianPoint : {fv} (fin fv) => Field fv -> Set (JacobianPoint fv);
is_JacobianPoint f s =
  ( f.is_val ((s:JacobianPoint fv).x)
  & f.is_val (s.y)
  & f.is_val (s.z)
  & implies (ec_is_zero_point (f,s))
            (s == ec_zero_point f)
  );

type PointOps (fv,gv) = {
       field : Field fv;
       double : JacobianPoint fv -> JacobianPoint fv;
       add : (JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv;
       sub : (JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv;
       group_field : Field gv;
     };

/* Double a Jacobian point */
/* Line numbers taken from Routine 2.2.6 in [NSA 2008] */
/* This version uses 4 multiplies and 4 squarings (4M + 4S).  The paper
   "A software implementation of NIST P-224" by Bernstein 2001 has a
   version that uses 3M + 5S.
   In that version, there are the following correspondances
     r7  = delta
     r11 = alpha
     r14 = gamma
     r15 = beta
     r16 = 4*beta
     r17 = alpha^2
     r18 = x3 = alpha^2 - 8*beta
     r12 = y1 * z1
   The key difference is to replace the computation of r13
    with "r13 = (s.y + s.z)^2 - s.y^2 - s.z^2".
   */
ec_double : {fv} (Field fv, JacobianPoint fv) -> JacobianPoint fv;
ec_double(f,s) =
  if is_zero(s.z) then
    { x = f.field_unit; y = f.field_unit; z = f.field_zero; } /* 5: r <- (1,1,0) and return */
  else
    { x = r18; y = r23; z = r13; }
 where {
   add = f.add;
   sub = f.sub;
   mul = f.mul;
   is_zero(x) = f.is_equal(x, f.field_zero);
   dbl(x) = f.add(x, x);
   mul3(x) = f.add(x, f.add(x, x));
   mul4(x) = dbl(dbl(x));
   mul8(x) = dbl(mul4(x));

   r7  = f.sq(s.z);          /*  7: t4 <- (t3)^2 */
   r8  = f.sub(s.x, r7);     /*  8: t5 <- t1 - t4 */
   r9  = add(s.x, r7);       /*  9: t4 <- t1 + t4 */
   r10 = mul(r9, r8);        /* 10: t5 <- t4 * t5 */
   r11 = mul3(r10);          /* 11: t4 <- 3 * t5 */
   r12 = mul(s.z, s.y);      /* 12: t3 <- t3 * t2 */
   r13 = dbl(r12);           /* 13: t3 <- 2 * t3 */
   r14 = f.sq(s.y);          /* 14: t2 <- (t2)^2 */
   r15 = mul(s.x, r14);      /* 15: t5 <- t1 * t2 */
   r16 = mul4(r15);          /* 16: t5 <- 4 * t5 */
   r17 = f.sq(r11);          /* 17: t1 <- (t4)^2 */    
   r18 = sub(sub(r17, r16), r16); /* 18: t1 <- t1 - 2 * t5 */
   r19 = f.sq(r14);          /* 19: t2 <- (t2)^2 */
   r20 = mul8(r19);          /* 20: t2 <- 8 * t2 */ 
   r21 = sub(r16, r18);      /* 21: t5 <- t5 - t1 */
   r22 = mul(r11, r21);      /* 22: t5 <- t4 * t5 */ 
   r23 = sub(r22, r20);      /* 23: t2 <- t5 - t2 */
  };

/**
 * Add a Jacobian point to an affine point over the given field.
 * Note: Will return { 0, 0, 0 } if points are equivalent, and double should be
 *       called.
 * Algorithm comes from Routine 2.2.7 in [NSA 2008].
 */
ec_add : {fv gv} (PointOps (fv, [gv]), JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv;
ec_add(p,s,t) =
  if is_zero(r13) then
    if is_zero(r14) then
      p.double(s) /* 17: r <- (0,0,0) and return */
    else
      { x = p.field.field_unit; y = p.field.field_unit; z = p.field.field_zero; } /* 19: r <- (1,1,0) and return */
  else
    { x = r32; y = r37; z = r27 }
  where {
   add = p.field.add;
   sub = p.field.sub;
   mul = p.field.mul;
   sq  = p.field.sq;
   is_zero(x) = p.field.is_equal(x, p.field.field_zero);
   dbl(x) = add(x, x);
   dbl_dec(x, y) = sub(sub(x, y), y);
   /* Line numbers from Routine 2.2.7 definition. */

   r9 = sq(s.z);             /*  9: t7 <- (t3)^2 */
   r10 = mul(t.x, r9);       /* 10: t4 <- t4 * t7 */
   r11 = mul(s.z, r9);       /* 11: t7 <- t3 * t7 */
   r12 = mul(t.y, r11);      /* 12: t5 <- t5 * t7 */
   r13 = sub(s.x, r10);      /* 13: t4 <- t1 - t4 */
   r14 = sub(s.y, r12);      /* 14: t5 <- t2 - t5 */

   r22 = sub(dbl(s.x), r13); /* 22: t1 <- 2*t1 - t4 */
   r23 = sub(dbl(s.y), r14); /* 23: t2 <- 2*t2 - t5 */

   r27 = mul(s.z, r13);      /* 27: t3 <- t3 * t4 */
   r28 = sq(r13);            /* 28: t7 <- (t4)^2 */
   r29 = mul(r13, r28);      /* 29: t4 <- t4 * t7 */
   r30 = mul(r22, r28);      /* 30: t7 <- t1 * t7 */
   r31 = sq(r14);            /* 31: t1 <- (t1)^2 */
   r32 = sub(r31, r30);      /* 32: t1 <- t1 - t7 */
   /*r33 = sub(r30, dbl(r32));*/ /* 33: t7 <- t7 - 2*t1 */
   /* The following is a better match for the Java implementation. */
   r33 = dbl_dec(r30, r32);  /* 33: t7 <- t7 - 2*t1 */
   r34 = mul(r14, r33);      /* 34: t5 <- t5 * t7 */
   r35 = mul(r23, r29);      /* 35: t4 <- t2 * t4 */
   r36 = sub(r34, r35);      /* 36: t2 <- t5 - t4 */
   r37 = p.field.half(r36);  /* 37: t2 <- t2/2 */
  };

/* Add Jacobian point to an affine point over the given field. */
/* Algorithm comes from Routine 2.2.8 in [NSA 2008] */
ec_full_add : {fv gv} (fin gv) => (PointOps (fv, [gv]), JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv;
ec_full_add(p, s, t) =
  if is_zero(s.z) then
    { x = t.x; y = t.y; z = p.field.field_unit }
  else
    ec_add(p, s, t)
 where {
   is_zero(x) = p.field.is_equal(x, p.field.field_zero);
 };

/* Subtract affine point from Jacobian point over the given field. */
/* Algorithm comes from Routine 2.2.9 in [NSA 2008] */
ec_full_sub : {fv gv} (PointOps (fv, [gv]), JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv;
ec_full_sub(p, s, t) = p.add(s, { x = t.x; y = p.field.neg(t.y); });

/* Scalar multiply operations {{{1 */

/* Multiplies a large word scalar by the an affine point. */
ec_mul : {fv gv}  (fin gv) => (PointOps (fv, [gv]), [gv], AffinePoint fv) -> JacobianPoint fv;
ec_mul (m, d, s) = res@`(gv+1)
  where {
    k = d # [False False];
    h = k + (k + k);
    res : [inf](JacobianPoint fv);
    res = [(ec_zero_point(m.field))]
          #  [| if hi & ~ki then
                  m.add(m.double(r), s)
                else if ~hi  & ki then
                  m.sub(m.double(r), s)
                else
                  m.double(r)
             || hi <- reverse(h) # zero
             || ki <- reverse(k) # zero
             || r  <- res |];
    };


/* Return d0 * S + d1 * T. All points projective, 0 <= d0, d1 < p. */
ec_twin_mul : {fv gv} (fin gv, gv >= 4) 
            => (PointOps (fv,[gv]), [gv], AffinePoint fv, [gv], AffinePoint fv)
            -> (JacobianPoint fv);
ec_twin_mul(m, d0, s, d1, t) =
  if ec_is_zero_point(f, sPtP) then /* s + t = 0 */
    ec_mul(m, g.sub(d0, d1), s)
  else if ec_is_zero_point(f, sMtP) then /* s = t */
    ec_mul(m, g.add(d0, d1), s)
  else
    r!0
 where {
   f = m.field;
   g = m.group_field;
   sP = ec_projectify(f, s);
   sPtP = m.add(sP, t); /* 1: ec_full_add (SpT, S, T) */
   sMtP = m.sub(sP, t); /* 2: ec_full_sub (SmT, S, T) */
   sDiv = f.div(f.field_unit, f.mul(sPtP.z, sMtP.z));
   sPt = { x = f.mul(g2, sPtP.x); y = f.mul(f.mul(g, g2), sPtP.y); }
    where { g = f.mul(sMtP.z, sDiv); g2 = f.sq(g) };
   sMt = { x = f.mul(g2, sMtP.x); y = f.mul(f.mul(g, g2), sMtP.y); }
    where { g = f.mul(sPtP.z, sDiv); g2 = f.sq(g) };
   F : [5] -> [5];
   F(t) = if (18 <= t) & (t < 22) then
            9
          else if (14 <= t) & (t < 18) then
            10
          else if (22 <= t) & (t < 24) then
            11
          else if (4 <= t) & (t < 12) then
            14
          else
            12;
   c = [[(zero # take(4, reverse(d0)))
         (zero # take(4, reverse(d1)))]]
     # [| [[(abs(u0) ^ c01) c02 c03 c04 c05 e0N]
           [(abs(u1) ^ c11) c12 c13 c14 c15 e1N]]
          where {
            abs : {a} (fin a) => [a] -> Bit;
            abs(x) = x != zero;
          }
       || [[c00 c01 c02 c03 c04 c05] [c10 c11 c12 c13 c14 c15]] <- c 
       || [u0 u1] <- u
       || e0N <- drop(4, reverse(d0)) # (zero : [4])
       || e1N <- drop(4, reverse(d1)) # (zero : [4])
       |];
   u = [| [u0 u1]
            where {
              h0' = [c05 c04 c03 c02 c01];
              h0 = if c00 then 31 - h0' else h0';
              h1' = [c15 c14 c13 c12 c11];
              h1 = if c10 then 31 - h1' else h1';
              u0 : [2];
              u0 = if h0 < F(h1) then 0 else if c00 then -1 else 1;
              u1 : [2];
              u1 = if h1 < F(h0) then 0 else if c10 then -1 else 1;
            }
       || [[c00 c01 c02 c03 c04 c05] [c10 c11 c12 c13 c14 c15]] <- c 
       |];
   r = [(ec_zero_point f)]
     # [| if      (u0 == -1) & (u1 == -1) then m.sub(r2, sPt)
          else if (u0 == -1) & (u1 ==  0) then m.sub(r2, s)
          else if (u0 == -1) & (u1 ==  1) then m.sub(r2, sMt)
          else if (u0 ==  0) & (u1 == -1) then m.sub(r2, t)
          else if (u0 ==  0) & (u1 ==  1) then m.add(r2, t)
          else if (u0 ==  1) & (u1 == -1) then m.add(r2, sMt)
          else if (u0 ==  1) & (u1 ==  0) then m.add(r2, s)
          else if (u0 ==  1) & (u1 ==  1) then m.add(r2, sPt)
          else r2
           where r2 = m.double(rP)
       || rP <- r
       || [u0 u1] <- u
       |];
 };

/* ECDSA Operations {{{1 */

/** Operations for ECDSA abstraction layer */
type Curve (fv,gv) = {
    point_ops : PointOps (fv,gv);
    base : AffinePoint fv;
    affinify : JacobianPoint fv -> AffinePoint fv;
    mul : (gv, AffinePoint fv) -> JacobianPoint fv;
    twin_mul : (gv, AffinePoint fv, gv, AffinePoint fv) -> JacobianPoint fv;
  };

/**
 * Reference ECDSA signature algorithm as formalized from [ANSI X9.62-2005, pg 8]
 * Parameters:
 *  Curve c
 *  Private key d of signatory.
 *  Integer e obtained after hashing message on step e)
 *  Ephemeral EC private key in range [1 .. c.curve)
 */
ecdsa_sign : {fv} (fin fv, fv >= 1) => (Curve ([fv],[fv]), [fv], [fv], [fv]) -> ([fv], [fv]);
ecdsa_sign(c,d,e,k) = if is_zero(r) | is_zero(s) then (0,0) else (r, s)
  where {
    g = c.point_ops.group_field;
    is_zero(x) = g.is_equal(x, g.field_zero);
    /* Compute x coordinate of public key. */
    j = (c.affinify(c.mul(k, c.base))).x;
    /* c) Set r = j mod n */
    r = g.norm(j);
    s = g.div(g.add(e, g.mul(d, r)), k);
  };

/**
 * Reference ECDSA signature verification algorithm as formalized from [ANSI X9.62-2005, pg 9]
 * Parameters
 *  Curve c
 *  Integer e' obtained after hashing message on  step "c".
 *  Pair returned by ref_ecdsa_sign algorithm.
 *  Public key of key signatory.
 * Result:
 *  Bit that is True if verification suceeds, and false otherwise.
 */
ecdsa_public_verify : {fv} (fin fv, fv >= 1)
   => (Curve ([fv],[fv]), [fv], ([fv], [fv]), AffinePoint [fv]) -> Bit;
ecdsa_public_verify(c, e, (r, s), q)
    /* h) Compare v and r' if v = r', output "valid"; otherwise output "invalid". */
   = in_range(s) & (v == r)
  where {
    f = c.point_ops.field;
    g = c.point_ops.group_field;
    mul(x,y) = g.mul(x, y);
    div(x,y) = g.div(x, y);
    is_zero(x) = g.is_equal(x, g.field_zero);
    in_range(x) = ~is_zero(x) & g.is_val(x);
    s_inv = div(1, s);
    u1 = mul(e, s_inv);
    u2 = mul(r, s_inv);
    r2 = c.twin_mul(u1, c.base, u2, q);
    /* f) Convert the field element x_r to an integer j as described in A.5 */
    j = f.mul(r2.x, f.sq(f.div(f.field_unit, r2.z)));
    /* g) v = j mod n */
    v = g.norm(j);
  };

/* P384 reference definitions {{{1 */

/* Utility functions {{{2 */ 

type RsltWithCarry (a,b) = { carry : a ; rslt : b };

p384_incFieldPrime : [384] -> RsltWithCarry ([32],[384]);
p384_incFieldPrime x = {carry = [(bs ! 0)] # zero; rslt = take(384, bs)}
  where bs = safe_add(x, p384_prime);

p384_decFieldPrime : [384] -> RsltWithCarry ([32],[384]);
p384_decFieldPrime x = { carry = if (bs ! 0) then -1 else 0; rslt = take(384, bs)}
  where bs = safe_sub(x, p384_prime);

/* P384 modular arithmetic definitions. {{{2 */

p384_safe_product : ([384], [384]) -> [768];
p384_safe_product (x, y) = safe_product(x, y);

p384_mod_add : ([384],[384],[384]) -> [384];
p384_mod_add = mod_add;

p384_mod_sub : ([384],[384],[384]) -> [384];
p384_mod_sub = mod_sub;

p384_mod_mul : ([384],[384],[384]) -> [384];
p384_mod_mul = mod_mul;

p384_mod_half : ([384],[384]) -> [384];
p384_mod_half = mod_half;

p384_mod_div : ([384],[384],[384]) -> [384];
p384_mod_div = mod_div;

/* P384 field definitions. {{{2 */

p384_prime : [384];
p384_prime = - (2 ** 384 + 2 ** 128 + 2 ** 96 - 2 ** 32 + 1);

// P384 field reference modulus.
p384_field_mod : [768] -> [384];
p384_field_mod(a)
    = take(384,
           if b1 then r0
           else if b2 then r1
           else if b3 then r2
           else if b4 then r3
           else r4)
  where {
    p       = p384_prime # (zero : [32]);
    rwc     = p384_field_mod_aux(a);
    z       = rwc.rslt;
    d       = rwc.carry;
    r       = z # d;
    r0      = if (d@31) then r + p else r; // fix potential underflow
    (r1,b1) = sbb(r0, p);
    (r2,b2) = sbb(r1, p);
    (r3,b3) = sbb(r2, p);
    (r4,b4) = sbb(r3, p);
   };

// tmp delete_me
p384_field_mod_aux_dummy : [64] -> RsltWithCarry ([32], [32]);
p384_field_mod_aux_dummy(a) = {carry = drop(32, r); rslt = take(32, r)} 
  where {
    [ a0 a1 ] = split a;
    z32       = zero : [32];
    t1        = a0 # z32;
    t2        = a1 # z32;
    r         = t1 + t2;
  };

tv = (zero : [736]) # 0x1;

p384_field_mod_aux_dummy2_temp : [768] -> ([64],[32],[32],[64],[32],[32]);
p384_field_mod_aux_dummy2_temp(a) = (zd0, z0, d0, zd1, z1, d1)
  where {
    [ a0  a1  a2  a3  a4  a5  a6  a7  a8  a9 a10 a11
     a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23 ]
            = [| zext x || x <- (split a : [24][32]) |];
    zext x  = x # (zero:[32]);
    chop x  = (take (32,x), drop(32, x));
    zd0     = a0 + a12 + a21 + a20 - a23; 
    zd1     = iext(d0) + a1 + a13 + a22 + a23 - a12 - a20;
    (z0,d0) = chop zd0;
    (z1,d1) = chop zd1;
  };

p384_field_mod_aux_dummy2 : [768] -> RsltWithCarry ([32],[384]);
 p384_field_mod_aux_dummy2(a) = { carry = d11; rslt = z0 # z1 # z2 # z3 # z4 # z5 # z6 # z7 # z8 # z9 # z10 # z11} 
  where {
    [ a0  a1  a2  a3  a4  a5  a6  a7  a8  a9 a10 a11
     a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23 ]
              = [| uext x || x <- (split a : [24][32]) |] : [24][64];
    chop x    = (take (32,x), drop(32, x));
    zd0       = a0 + a12  + a21 + a20 - a23; 
    zd1       = iext(d0)  + a1 + a13 + a22 + a23 - a12 - a20;
    zd2       = iext(d1)  + a2 + a14 + a23 - a13 - a21;
    zd3       = iext(d2)  + a3 + a15 + a12 + a20 + a21 - a14 - a22 - a23;
    zd4       = iext(d3)  + a4 + (a21 << 1) + a16 + a13 + a12 + a20 + a22 - a15 - (a23 << 1);
    zd5       = iext(d4)  + a5 + (a22 << 1) + a17 + a14 + a13 + a21 + a23 - a16;
    zd6       = iext(d5)  + a6 + (a23 << 1) + a18 + a15 + a14 + a22 - a17;
    zd7       = iext(d6)  + a7 + a19 + a16 + a15 + a23 - a18;
    zd8       = iext(d7)  + a8 + a20 + a17 + a16 - a19;
    zd9       = iext(d8)  + a9 + a21 + a18 + a17 - a20;
    zd10      = iext(d9)  + a10 + a22 + a19 + a18 - a21;
    zd11      = iext(d10) + a11 + a23 + a20 + a19 - a22;
    (z0,d0)   = chop zd0;
    (z1,d1)   = chop zd1;
    (z2,d2)   = chop zd2;
    (z3,d3)   = chop zd3;
    (z4,d4)   = chop zd4;
    (z5,d5)   = chop zd5;
    (z6,d6)   = chop zd6;
    (z7,d7)   = chop zd7;
    (z8,d8)   = chop zd8;
    (z9,d9)   = chop zd9;
    (z10,d10) = chop zd10;
    (z11,d11) = chop zd11;
  };
// tmp delete_me

p384_field_mod_aux : [768] -> RsltWithCarry ([32],[384]);
p384_field_mod_aux(a) = {carry = drop(384, r); rslt = take(384, r)}
  where {
    [ a0  a1  a2  a3  a4  a5  a6  a7  a8  a9 a10 a11
     a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23]
        = split a;
    z32 = zero : [32];
    z64 = zero : [64];
    p   = p384_prime # z32;
    t   =  a0 #  a1 #  a2 #  a3 #  a4 #  a5 #  a6 #  a7 #  a8 #  a9 # a10 # a11 # z32;
    s1  =     (zero : [128])    # a21 # a22 # a23 #      (zero : [160])         # z32;
    s2  = a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # a21 # a22 # a23 # z32;
    s3  = a21 # a22 # a23 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # z32; 
    s4  = z32 # a23 # z32 # a20 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # z32;
    s5  =     (zero : [128])    # a20 # a21 # a22 # a23 #    (zero : [128])     # z32;
    s6  = a20 #    z64    # a21 # a22 # a23 #          (zero : [192])           # z32;
    d1  = a23 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # a21 # a22 # z32;
    d2  = z32 # a20 # a21 # a22 # a23 #              (zero : [224])             # z32;
    d3  =  (zero : [96])  # a23 # a23 #              (zero : [224])             # z32;
    r   = t + (s1 << 1) + s2 + s3 + s4 + s5 + s6 - d1 - d2 - d3;
  };
  
theorem p384_field_mod_aux_ok: {x}. p384_field_mod_orig(x) == p384_field_mod(x);

p384_field_mod_orig : [768] -> [384];
p384_field_mod_orig(a)
    = take(384,
           if b1 then r 
           else if b2 then r1
           else if b3 then r2
           else if b4 then r3
           else r4)
  where {
    [ a0  a1  a2  a3  a4  a5  a6  a7  a8  a9 a10 a11
     a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23]
       = split a;
    z32 = zero : [32];
    z64 = zero : [64];
    p = p384_prime # z32;
    t  =  a0 #  a1 #  a2 #  a3 #  a4 #  a5 #  a6 #  a7 #  a8 #  a9 # a10 # a11 # z32;
    s1 =     (zero : [128])    # a21 # a22 # a23 #      (zero : [160])         # z32;
    s2 = a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # a21 # a22 # a23 # z32;
    s3 = a21 # a22 # a23 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # z32; 
    s4 = z32 # a23 # z32 # a20 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # z32;
    s5 =     (zero : [128])    # a20 # a21 # a22 # a23 #    (zero : [128])     # z32;
    s6 = a20 #    z64    # a21 # a22 # a23 #          (zero : [192])           # z32;
    d1 = a23 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # a21 # a22 # z32;
    d2 = z32 # a20 # a21 # a22 # a23 #              (zero : [224])             # z32;
    d3 =  (zero : [96])  # a23 # a23 #              (zero : [224])             # z32;
    d1' = p - d1;
    r = t + (s1 << 1) + s2 + s3 + s4 + s5 + s6 + d1' - d2 - d3;
    (r1,b1) = sbb(r, p);
    (r2,b2) = sbb(r1, p);
    (r3,b3) = sbb(r2, p);
    (r4,b4) = sbb(r3, p);
   };

// Give explicit names to these finite field operators, so SBV
//  can uninterpret them.
p384_is_field_val  = is_normal p384_prime;

p384_field_add(x,y) = p384_mod_add(p384_prime, x, y);
p384_field_sub(x,y) = p384_mod_sub(p384_prime, x, y);
/* p384_field_neg(x) returns -x mod p384_prime. */
p384_field_neg(x)        = if x == 0 then 0 else (p384_prime - x);

p384_field_mul : ([384],[384]) -> [384];
p384_field_mul(x,y)      = p384_field_mod(p384_safe_product(x, y));

p384_field_sq(x)         = p384_field_mul(x, x);
p384_field_cube(x)       = p384_field_mul(x, p384_field_sq(x));


/* Defines a reference prime field that uses normalized numbers and
   large word bit operations. */
p384_field :  Field [384];
p384_field = {
    is_val     = p384_is_field_val;
    norm       = \x -> if x < p384_prime then x else x - p384_prime;
    add        = p384_field_add;
    sub        = p384_field_sub;
    neg        = p384_field_neg;
    mul        = p384_field_mul;
    sq         = p384_field_sq;
    half       = \x -> p384_mod_half(p384_prime, x);
    div        = \(x,y) -> p384_mod_div(p384_prime, x, y);
    field_zero = 0;
    field_unit = 1;
    is_equal   = \(x,y) -> x == y;
    };

/* P384 group field operations {{{2 */

p384_group_size : [384];
p384_group_size =
  join(reverse 
    [0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff
     0xc7634d81 0xf4372ddf 0x581a0db2 0x48b0a77a 0xecec196a 0xccc52973]);

/* Defines a reference prime field that uses normalized numbers and
   large word bit operations. */
p384_group_field :  Field [384];
p384_group_field = {
    is_val     = is_normal p384_group_size;
    norm       = \x -> if x < p384_group_size then x else x - p384_group_size;
    add        = \(x,y) -> p384_mod_add(p384_group_size, x, y);
    sub        = \(x,y) -> p384_mod_sub(p384_group_size, x, y);
    neg        = \x     -> mod_neg(p384_group_size, x);
    mul        = \(x,y) -> p384_mod_mul(p384_group_size, x, y);
    sq         = \x     -> mod_mul(p384_group_size, x, x);
    half       = \x     -> mod_half(p384_group_size, x);
    div        = \(x,y) -> p384_mod_div(p384_group_size, x, y);
    field_zero = 0;
    field_unit = 1;
    is_equal   = \(x,y) -> x == y;
    };

/** P384 curve operations {{{2 */

p384_base : AffinePoint [384];
p384_base = nzAffinePoint(
  join(reverse
       [0xaa87ca22 0xbe8b0537 0x8eb1c71e 0xf320ad74 0x6e1d3b62 0x8ba79b98
        0x59f741e0 0x82542a38 0x5502f25d 0xbf55296c 0x3a545e38 0x72760ab7]),
  join(reverse
       [0x3617de4a 0x96262c6f 0x5d9e98bf 0x9292dc29 0xf8f41dbd 0x289a147c
        0xe9da3113 0xb5f0b8c0 0x0a60b1ce 0x1d7e819d 0x7a431d7c 0x90ea0e5f]));

p384_ec_zero_point : JacobianPoint [384];
p384_ec_zero_point = ec_zero_point(p384_field);

p384_ec_double : JacobianPoint [384] -> JacobianPoint [384];
p384_ec_double(p) = ec_double(p384_field, p);

p384_ec_full_add : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384];

p384_ec_full_sub : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384];

p384_point_ops : PointOps ([384],[384]);
p384_point_ops = {
    field = p384_field;
    double = p384_ec_double;
    add = p384_ec_full_add;
    sub = p384_ec_full_sub;
    group_field = p384_group_field;
  };

p384_ec_full_add(p,q) = ec_full_add(p384_point_ops, p, q);
p384_ec_full_sub(p,q) = ec_full_sub(p384_point_ops, p, q);

java_ishl : ([32],[32]) -> [32];
java_ishl (x,s) = x << (s & 0x1f);

/* Matches Java implementation */
p384_ec_mul_aux : ( JacobianPoint [384]
                   , AffinePoint [384]
                   , [32], [32], [32], [32], [32] ) -> JacobianPoint [384];
p384_ec_mul_aux (r, s, j, hi, i_lt_11, d_at_i, d_at_ip1) = r'
  where {
    m   = java_ishl(1, j);
    ki  = d_at_i >> 1;
    ki' = if i_lt_11 != 0 then ki | ((d_at_ip1 & 1) << 31) else ki;
    r'' = p384_ec_double(r);
    r'  = if ((hi & m) != zero) & ((ki' & m) == zero) then
            p384_ec_full_add(r'', s)
          else if ((hi & m) == zero) & ((ki' & m) != zero) then
            p384_ec_full_sub(r'', s)
          else r'';
  };

p384_ec_mul_init : ([384], AffinePoint [384]) ->
                   { h: [384]; r: JacobianPoint [384]; };
p384_ec_mul_init (d, s) = { h = join h0; r = r0 }
  where {
    d' : [12][32];
    d' = split d;
    (h0, c) = ripple_adc(d', ripple_shr(d', False));
    r0 = if c then ec_projectify(p384_field, s)
              else p384_ec_zero_point;
  };

/* Matches Java implementation */
p384_ec_mul : ([384], AffinePoint [384]) -> JacobianPoint [384];
p384_ec_mul (d, s) = (res @ 384)
  where {
    d' : [12][32];
    d' = split d;
    ini =  p384_ec_mul_init(d, s);
    h : [12][32];
    h = split (ini.h);
    r0 = ini.r;
    f (j, r) = p384_ec_mul_aux(r, s, j, h @ i, [c] # zero, d'@i, d_at_ip1)
      where {
        i        = j >> 5;
        c        = i < 11;
        d_at_ip1 = if c then d'@(i+1) else 0; 
                   /* NB: We guard indexing here to avoid bounds VCs;
                      p384_ec_mul_aux's use of d_at_ip1 is likewise
                      guarded. */
      };
    res = [r0] #
          [| f(j, r)
          || j <- mk_strm (reverse [0..383])
          || r <- res
          |]
  };

/*
p384_ec_mul_aux : ( JacobianPoint [384]
                   , AffinePoint [384]
                   , [32], [32], [32] ) -> JacobianPoint [384];
p384_ec_mul_aux (r, s, m, hi, ki) = r'
  where {
    r'' = p384_ec_double(r);
    r' = if ((hi & m) != zero) & ((ki & m) == zero) then
           p384_ec_full_add(r'', s)
         else if ((hi & m) == zero) & ((ki & m) != zero) then
           p384_ec_full_sub(r'', s)
         else r'';
  };
*/

/*
p384_ec_mul (d, s) = (res @ 384)
  where {
    d' : [12][32];
    d' = split d;
    (h, c) = ripple_adc(d', ripple_shr(d', False));
    r0 = if c
          then ec_projectify(p384_field, s)
          else p384_ec_zero_point;
    f (j, r) = p384_ec_mul_aux(r, s, 1 << j, h @ i, ki')
      where {
        i = j >> 5;
        ki = (d' @ i) >> 1;
        ki' = if i < 11 then ki | (((d' @ (i+1)) & 1) << 31) else ki;
      };
    res = [r0] #
          [| f(j, r)
          || j <- mk_strm (reverse [0..383])
          || r <- res
          |]
  };
*/

p384_ec_twin_mul : ([384], AffinePoint [384], [384], AffinePoint [384]) -> (JacobianPoint [384]);
p384_ec_twin_mul(x,p,y,q) = ec_twin_mul(p384_point_ops, x, p, y, q);

p384_group_add : ([384],[384]) -> [384];
p384_group_add = p384_group_field.add;

p384_curve : Curve ([384],[384]);
p384_curve = {
    point_ops = p384_point_ops;
    base = p384_base;
    affinify = \x -> ec_affinify(p384_field, x);
    mul = p384_ec_mul;
    twin_mul = p384_ec_twin_mul;
  };

p384_ecdsa_sign : ([384], [384], [384]) -> ([384],[384]);
p384_ecdsa_sign(d,e,k) = ecdsa_sign(p384_curve,d,e,k);

p384_ecdsa_public_verify : ([384], ([384],[384]), AffinePoint [384]) -> Bit;
p384_ecdsa_public_verify(e,p,q) = ecdsa_public_verify(p384_curve,e,p,q);

/* P384 test code {{{2 */

/* Curve "a" parameter, defined in [FIPS-186-3, page 87] to be -3 */
p384_a : [384];
p384_a = p384_prime - 3;

/* Curve "b" parameter, defined in [FIPS-186-3, page 89] */
p384_b : [384];
p384_b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef;

/* Point "S" defined in [NSA 2008, Section 4.4.2] */
p384_s : AffinePoint [384];
p384_s = nzAffinePoint(
  join(reverse
        [0xfba203b8 0x1bbd23f2 0xb3be971c 0xc23997e1 0xae4d89e6 0x9cb6f923
         0x85dda827 0x68ada415 0xebab4167 0x459da98e 0x62b1332d 0x1e73cb0e]),
  join(reverse
        [0x5ffedbae 0xfdeba603 0xe7923e06 0xcdb5d0c6 0x5b223014 0x29293376
         0xd5c6944e 0x3fa6259f 0x162b4788 0xde6987fd 0x59aed5e4 0xb5285e45]));

/* Point "T" defined in [NSA 2008, Section 4.4.2] */
p384_t : AffinePoint [384];
p384_t = nzAffinePoint(
  join(reverse
        [0xaacc0520 0x2e7fda6f 0xc73d82f0 0xa6622052 0x7da8117e 0xe8f8330e
         0xad7d20ee 0x6f255f58 0x2d8bd38c 0x5a7f2b40 0xbcdb68ba 0x13d81051]),
  join(reverse
        [0x84009a26 0x3fefba7c 0x2c57cffa 0x5db3634d 0x286131af 0xc0fca8d2
         0x5afa22a7 0xb5dce0d9 0x470da892 0x33cee178 0x592f49b6 0xfecb5092]));

/* Multiple "D" defined in [NSA 2008, Section 4.4.2] */
p384_d =
  join(reverse
        [0xa4ebcae5 0xa6659834 0x93ab3e62 0x6085a24c 0x104311a7 0x61b5a8fd
         0xac052ed1 0xf111a5c4 0x4f76f456 0x59d2d111 0xa61b5fdd 0x97583480]);

/* Multiple "E" defined in [NSA 2008, Section 4.4.2] */
p384_e =
  join(reverse
        [0xafcf8811 0x9a3a76c8 0x7acbd600 0x8e1349b2 0x9f4ba9aa 0x0e12ce89
         0xbcfcae21 0x80b38d81 0xab8cf150 0x95301a18 0x2afbc689 0x3e75385d]);

/* Convert a p384 Jacobian point to an affine point */
p384_affinify : JacobianPoint [384] -> AffinePoint [384];
p384_affinify p = ec_affinify(p384_field, p);

/* Convert a p384 affine point to a Jacobian point */
p384_jacobify : AffinePoint [384] -> JacobianPoint [384];
p384_jacobify p = { x = p.x; y = p.y; z = 1 };

/* Does an affine point lie on the curve? */
p384_is_affine_point : AffinePoint [384] -> Bit;
p384_is_affine_point p =
  p384_field_sq(p.y) ==
  p384_field_add(p384_field_cube(p.x),
                 p384_field_add(p384_field_mul(p384_a, p.x), p384_b));

/* P384 implementation curve definition {{{1 */

/* Chunked arithmetic routines {{{2 */

/* Promote a finite sequence to an infinite sequence */
mk_strm : {a b} fin a => [a][b] -> [inf][b];
mk_strm x = x # zero;

/* Adds two n*m bit numbers split into m-bit segments and returns carry. */
ripple_adc : {m  n} (m >= 1, fin m, fin n) => ([n][m],[n][m]) -> ([n][m],Bit);
ripple_adc(xx,yy) = (values, carry_strm @ (width xx))
  where {
    adc(x,y,c) = (take(width x,sum), sum @ width x)
      where sum = safe_add(x,y) + uext([c]);
    list_strm = [| adc(a,b,c)
           || a <- mk_strm xx
           || b <- mk_strm yy
           || c <- carry_strm
           |];
    list = take(width xx,list_strm);
    values = [| v || (v,_) <- list |];
    carry_strm  = [False] # [| c || (_,c) <- list_strm |];
  };

/* Returns (xl # c) >> 1. */
ripple_shr : {m n} (m >= 1, fin m, n >= 1, fin n) => ([n][m],Bit) -> ([n][m]);
ripple_shr(xl,c) = [| (x' << (width(x) - 1)) | (x >> 1)
                   || x <- xl
                   || x' <- drop(1,xl) # [(uext([c]))] |];
