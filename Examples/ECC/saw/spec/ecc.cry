include "Field.cry"; /* Defines Field type and generic operations */

/* Field primitives common to group and underlying field. {{{1 */

/* Unsigned word extension. */
uext : {a b} (b >= a, fin a) => [a] -> [b];
uext(x) = x # zero;

iext : {a b} (b >= a, fin a) => [a] -> [b];
iext(x) = x # (if x!0 then ~zero else zero);

/* Returns the (n+1)-bit sum of two n-bit numbers. */
safe_add : {n} (fin n) => ([n],[n]) -> [n+1];
safe_add(x,y) = uext(x) + uext(y);

/* returns the (n+1)-bit subtraction of two n-bit numbers. */
safe_sub : {n} (fin n) => ([n],[n]) -> [n+1];
safe_sub(x,y) = uext(x) - uext(y);

/* Is x in normalized form (relative to prime p)? */
is_normal : {a} (fin a) => [a] -> [a] -> Bit;
is_normal p x = (x < p);

/* Returns the product of two inputs. */
safe_product : {a} (fin a) => ([a],[a]) -> [2*a];
safe_product(x,y) = uext(x) * uext(y);

/* Returns module reduction on input. */
safe_mod : {a b} (fin a, fin b) => ([b],[a]) -> [b];
safe_mod(p,x) = take(width(p), (x # zero) % (p # zero));

/* Add two n-bit numbers and input carry to obtain a n bit number and output carry. */
ref_adc : {n} (fin n) => ([n],[n]) -> ([n],Bit);
ref_adc(x,y) = (take(width x,sum), sum @ width x)
  where sum = safe_add(x,y);

/* ref_sbb(x,y,b) subtracts y+b from x, and returns result along with output borrow bit. */
ref_sbb : {n} (fin n) => ([n],[n]) -> ([n],Bit);
ref_sbb(x,y) = (take(width x, r), ~(r ! 0))
  where r = (x # [True]) - (y # [False]);

/* Add two numbers in normalized form. */
ref_prime_add : {n} (fin n) => ([n],[n],[n]) -> [n];
ref_prime_add(p,x,y) = if c1 | ~c2 then r2 else r1
  where {
    (r1,c1) = ref_adc( x, y);
    (r2,c2) = ref_sbb(r1, p);
  };

/* Subtract two numbers in normalized form. */
ref_prime_sub : {n} (fin n) => ([n],[n],[n]) -> [n];
ref_prime_sub(p,x,y) = if b then r2 else r1
  where {
    (r1,b) = ref_sbb( x, y);
    (r2,_) = ref_adc(r1, p);
  };

/* Returns x/y in F_p using Euler's binary gcd algorithm. */
/* Taken from [HMV] */
ref_prime_div : {a} (fin a, a >= 1) => ([a],[a],[a]) -> [a];
ref_prime_div(p,x,y) = egcd(p,0,y,x)
  where {
    even : {a} (fin a, a >= 0) => [a+1] -> Bit;
    even x = ~(x@0);
    /* Returns x / 2. */
    half x = if even(x) then x >> 1 else drop(1, safe_add(x, p));
    /* In code below, a is always odd. */
    egcd(a,ra,b,rb) =
      if b == 0 then
        ra
      else 
        egcd(if even(b) then
               (a, ra, b >> 1, half(rb))
             else if a < b then
               (a, ra, (b - a) >> 1, half(ref_prime_sub(p, rb, ra)))
             else 
               (b, rb, (a - b) >> 1, half(ref_prime_sub(p, ra, rb))));
    pragma egcd: ISABELLE skipTerminationProof;
  };

/* Affine points {{{1 */

type AffinePoint fv = { x : fv; y : fv; };

/* Return an affine point. */
nzAffinePoint : {fv} (fv,fv) -> AffinePoint fv;
nzAffinePoint (ax,ay) = { x = ax; y = ay };

/* Morphisms between affine points */
type AffinePoint_Mor (iv,rv) = Mor (AffinePoint iv,
                                    AffinePoint rv);

/* Define Jacobian points */
type JacobianPoint fv = { x : fv; y : fv; z : fv; };

/* Morphisms between Jacobian points */
type JacobianPoint_Mor (iv,rv) = Mor (JacobianPoint iv,
                                      JacobianPoint rv);

/* Create projective value from affine. */
/* Routine 2.2.1 in [NSA 2008] */
ec_projectify : {fv} (Field fv, AffinePoint fv) -> JacobianPoint fv;
ec_projectify(f,s) = { x = s.x; y = s.y; z = f.field_unit };

/* Returns zero point. */
ec_zero_point : {fv} Field fv -> JacobianPoint fv;
ec_zero_point(f) = { x = f.field_unit; y = f.field_unit; z = f.field_zero };

/* Checks to see if point is zero. */
ec_is_zero_point : {fv} (Field fv, JacobianPoint fv) -> Bit;
ec_is_zero_point(f,s) = f.is_equal(s.z, f.field_zero);

/* Is the Jacobian point well-formed? Here we assume
** the only valid zero-point is the unit zero point.
** NOTE: The output of ECC operations in this file always
**   satisfies this assumption. However, they are more
**   permissive in their inputs, i.e. they still do the
**   right thing when given a non-unit zero point.
*/
is_JacobianPoint : {fv} (fin fv) => Field fv -> Set (JacobianPoint fv);
is_JacobianPoint f s =
  ( f.is_val ((s:JacobianPoint fv).x)
  & f.is_val (s.y)
  & f.is_val (s.z)
  & implies (ec_is_zero_point (f,s))
            (s == ec_zero_point f)
  );

ec_affinify : {fv} (Field fv, JacobianPoint fv) -> AffinePoint fv;
ec_affinify(f,s) = { x = f.mul(g2, s.x); y = f.mul(g3, s.y); }
  where { g = f.div(f.field_unit, s.z); g2 = f.sq(g); g3 = f.mul(g, g2); };

/* Double a Jacobian point */
/* Line numbers taken from Routine 2.2.6 in [NSA 2008] */
/* This version uses 4 multiplies and 4 squarings (4M + 4S).  The paper
   "A software implementation of NIST P-224" by Bernstein 2001 has a
   version that uses 3M + 5S.
   In that version, there are the following correspondances
     r7  = delta
     r11 = alpha
     r14 = gamma
     r15 = beta
     r16 = 4*beta
     r17 = alpha^2
     r18 = x3 = alpha^2 - 8*beta
     r12 = y1 * z1
   The key difference is to replace the computation of r13
    with "r13 = (s.y + s.z)^2 - s.y^2 - s.z^2".
   */
ec_double : {fv} (Field fv, JacobianPoint fv) -> JacobianPoint fv;
ec_double(f,s) =
  if is_zero(s.z) then
    { x = f.field_unit; y = f.field_unit; z = f.field_zero; } /* 5: r <- (1,1,0) and return */
  else
    { x = r18; y = r23; z = r13; }
 where {
   add = f.add;
   sub = f.sub;
   mul = f.mul;
   is_zero(x) = f.is_equal(x, f.field_zero);
   dbl(x) = f.add(x, x);
   mul3(x) = f.add(x, f.add(x, x));
   mul4(x) = dbl(dbl(x));
   mul8(x) = dbl(mul4(x));

   r7  = f.sq(s.z);          /*  7: t4 <- (t3)^2 */
   r8  = f.sub(s.x, r7);     /*  8: t5 <- t1 - t4 */
   r9  = add(s.x, r7);       /*  9: t4 <- t1 + t4 */
   r10 = mul(r9, r8);        /* 10: t5 <- t4 * t5 */
   r11 = mul3(r10);          /* 11: t4 <- 3 * t5 */
   r12 = mul(s.z, s.y);      /* 12: t3 <- t3 * t2 */
   r13 = dbl(r12);           /* 13: t3 <- 2 * t3 */
   r14 = f.sq(s.y);          /* 14: t2 <- (t2)^2 */
   r15 = mul(s.x, r14);      /* 15: t5 <- t1 * t2 */
   r16 = mul4(r15);          /* 16: t5 <- 4 * t5 */
   r17 = f.sq(r11);          /* 17: t1 <- (t4)^2 */    
   r18 = sub(sub(r17, r16), r16); /* 18: t1 <- t1 - 2 * t5 */
   r19 = f.sq(r14);          /* 19: t2 <- (t2)^2 */
   r20 = mul8(r19);          /* 20: t2 <- 8 * t2 */ 
   r21 = sub(r16, r18);      /* 21: t5 <- t5 - t1 */
   r22 = mul(r11, r21);      /* 22: t5 <- t4 * t5 */ 
   r23 = sub(r22, r20);      /* 23: t2 <- t5 - t2 */
  };


/**
 * Add a Jacobian point to an affine point over the given field.
 * Note: Will return { 0, 0, 0 } if points are equivalent, and double should be
 *       called.
 * Algorithm comes from Routine 2.2.7 in [NSA 2008].
 */
ec_add : {fv} (Field fv, JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv;
ec_add(f,s,t) =
  if is_zero(r13) then
    if is_zero(r14) then
      { x = f.field_zero; y = f.field_zero; z = f.field_zero; } /* 17: r <- (0,0,0) and return */
    else
      { x = f.field_unit; y = f.field_unit; z = f.field_zero; } /* 19: r <- (1,1,0) and return */
  else
    { x = r32; y = r37; z = r27 }
  where {
   add = f.add;
   sub = f.sub;
   mul = f.mul;
   sq  = f.sq;
   is_zero(x) = f.is_equal(x, f.field_zero);
   dbl(x) = add(x, x);
   /* Line numbers from Routine 2.2.7 definition. */

   r9 = sq(s.z);             /*  9: t7 <- (t3)^2 */
   r10 = mul(t.x, r9);       /* 10: t4 <- t4 * t7 */
   r11 = mul(s.z, r9);       /* 11: t7 <- t3 * t7 */
   r12 = mul(t.y, r11);      /* 12: t5 <- t5 * t7 */
   r13 = sub(s.x, r10);      /* 13: t4 <- t1 - t4 */
   r14 = sub(s.y, r12);      /* 14: t5 <- t2 - t5 */

   r22 = sub(dbl(s.x), r13); /* 22: t1 <- 2*t1 - t4 */
   r23 = sub(dbl(s.y), r14); /* 23: t2 <- 2*t2 - t5 */

   r27 = mul(s.z, r13);      /* 27: t3 <- t3 * t4 */
   r28 = sq(r13);            /* 28: t7 <- (t4)^2 */
   r29 = mul(r13, r28);      /* 29: t4 <- t4 * t7 */
   r30 = mul(r22, r28);      /* 30: t7 <- t1 * t7 */
   r31 = sq(r14);            /* 31: t1 <- (t1)^2 */
   r32 = sub(r31, r30);      /* 32: t1 <- t1 - t7 */
   r33 = sub(r30, dbl(r32)); /* 33: t7 <- t7 - 2*t1 */
   r34 = mul(r14, r33);      /* 34: t5 <- t5 * t7 */
   r35 = mul(r23, r29);      /* 35: t4 <- t2 * t4 */
   r36 = sub(r34, r35);      /* 36: t2 <- t5 - t4 */
   r37 = f.half(r36);        /* 37: t2 <- t2/2 */
  };

/* Add Jacobian point to an affine point over the given field. */
/* Algorithm comes from Routine 2.2.8 in [NSA 2008] */
ec_full_add : {fv} (Field fv, JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv;
ec_full_add(f, s, t) =
  if is_zero(s.z) then
    { x = t.x; y = t.y; z = f.field_unit }
  else if is_zero(r.x) & is_zero(r.y) & is_zero(r.z) then
    ec_double(f, s)
  else
    r
 where {
   r = ec_add(f, s, t);
   is_zero(x) = f.is_equal(x, f.field_zero);
 };

/* Subtract affine point from Jacobian point over the given field. */
/* Algorithm comes from Routine 2.2.9 in [NSA 2008] */
ec_full_sub : {fv} (Field fv, JacobianPoint fv, AffinePoint fv) -> JacobianPoint fv;
ec_full_sub(f, s, t) = ec_full_add(f, s, { x = t.x; y = f.neg(t.y); });

/* Multiplies a large word scalar by the an affine point. */
ec_ref_mul : {fv gv}  (fin gv) => (Field fv, [gv], AffinePoint fv) -> JacobianPoint fv;
ec_ref_mul (f, d, s) = res@`(gv+1)
  where {
    k = d # [False False];
    h = k + (k + k);
    res : [inf](JacobianPoint fv);
    res = [(ec_zero_point f)]
          #  [| if hi & ~ki then
                  ec_full_add(f, ec_double(f, r), s)
                else if ~hi  & ki then
                  ec_full_sub(f, ec_double(f, r), s)
                else
                  ec_double(f, r)
             || hi <- reverse(h) # zero
             || ki <- reverse(k) # zero
             || r  <- res |];
    };

/* Return d0 * S + d1 * T. All points projective, 0 <= d0, d1 < p. */
ec_ref_twin_mul : {fv gv} (fin gv, gv >= 4) 
            => (Field fv, [gv], [gv], AffinePoint fv, [gv], AffinePoint fv)
            -> (JacobianPoint fv);
ec_ref_twin_mul(f,gP, d0, s, d1, t) =
  if ec_is_zero_point(f, sPtP) then /* s + t = 0 */
    ec_ref_mul(f,ref_prime_sub(gP, d0, d1), s)
  else if ec_is_zero_point(f, sMtP) then /* s = t */
    ec_ref_mul(f,ref_prime_add(gP, d0, d1), s)
  else
    r!0
 where {
   sP = ec_projectify(f, s);
   sPtP = ec_full_add(f, sP, t); /* 1: ec_full_add (SpT, S, T) */
   sMtP = ec_full_sub(f, sP, t); /* 2: ec_full_sub (SmT, S, T) */
   sDiv = f.div(f.field_unit, f.mul(sPtP.z, sMtP.z));
   sPt = { x = f.mul(g2, sPtP.x); y = f.mul(f.mul(g, g2), sPtP.y); }
    where { g = f.mul(sMtP.z, sDiv); g2 = f.sq(g) };
   sMt = { x = f.mul(g2, sMtP.x); y = f.mul(f.mul(g, g2), sMtP.y); }
    where { g = f.mul(sPtP.z, sDiv); g2 = f.sq(g) };
   F : [5] -> [5];
   F(t) = if (18 <= t) & (t < 22) then
            9
          else if (14 <= t) & (t < 18) then
            10
          else if (22 <= t) & (t < 24) then
            11
          else if (4 <= t) & (t < 12) then
            14
          else
            12;
   c = [[(zero # take(4, reverse(d0)))
         (zero # take(4, reverse(d1)))]]
     # [| [[(abs(u0) ^ c01) c02 c03 c04 c05 e0N]
           [(abs(u1) ^ c11) c12 c13 c14 c15 e1N]]
          where {
            abs : {a} (fin a) => [a] -> Bit;
            abs(x) = x != zero;
          }
       || [[c00 c01 c02 c03 c04 c05] [c10 c11 c12 c13 c14 c15]] <- c 
       || [u0 u1] <- u
       || e0N <- drop(4, reverse(d0)) # (zero : [4])
       || e1N <- drop(4, reverse(d1)) # (zero : [4])
       |];
   u = [| [u0 u1]
            where {
              h0' = [c05 c04 c03 c02 c01];
              h0 = if c00 then 31 - h0' else h0';
              h1' = [c15 c14 c13 c12 c11];
              h1 = if c10 then 31 - h1' else h1';
              u0 : [2];
              u0 = if h0 < F(h1) then 0 else if c00 then -1 else 1;
              u1 : [2];
              u1 = if h1 < F(h0) then 0 else if c10 then -1 else 1;
            }
       || [[c00 c01 c02 c03 c04 c05] [c10 c11 c12 c13 c14 c15]] <- c 
       |];
   r = [(ec_zero_point f)]
     # [| if      (u0 == -1) & (u1 == -1) then ec_full_sub(f, r2, sPt)
          else if (u0 == -1) & (u1 ==  0) then ec_full_sub(f, r2, s)
          else if (u0 == -1) & (u1 ==  1) then ec_full_sub(f, r2, sMt)
          else if (u0 ==  0) & (u1 == -1) then ec_full_sub(f, r2, t)
          else if (u0 ==  0) & (u1 ==  1) then ec_full_add(f, r2, t)
          else if (u0 ==  1) & (u1 == -1) then ec_full_add(f, r2, sMt)
          else if (u0 ==  1) & (u1 ==  0) then ec_full_add(f, r2, s)
          else if (u0 ==  1) & (u1 ==  1) then ec_full_add(f, r2, sPt)
          else r2
           where r2 = ec_double(f, rP)
       || rP <- r
       || [u0 u1] <- u
       |];
 };

/* AffinePoint morphism constructor */
AffinePoint_mor : {a b} Mor (a,b) -> AffinePoint_Mor (a,b);
AffinePoint_mor m pt =
  { x = m ((pt:AffinePoint a).x)
  ; y = m (pt.y)
  };

/* JacobianPoint EP-pairs */
type JacobianPoint_EP (a,b) = EP (JacobianPoint a, JacobianPoint b);

/* JacobianPoint morphism constructor */
JacobianPoint_mor : {a b} Mor (a,b) -> JacobianPoint_Mor (a,b);
JacobianPoint_mor m pt =
  { x = m ((pt:JacobianPoint a).x)
  ; y = m (pt.y)
  ; z = m (pt.z)
  };

JacobianPoint_p384_emb : JacobianPoint_Mor ([12][32],[384]);
JacobianPoint_p384_emb = JacobianPoint_mor p384_emb;

/* JacobianPoint EP-pair constructor */
JacobianPoint_ep : {a b} EP (a,b) -> JacobianPoint_EP (a,b);
JacobianPoint_ep p =
  EP (JacobianPoint_mor (Emb p))
     (JacobianPoint_mor (Prj p));

type Curve fv = {
    field : Field fv;
    base : AffinePoint fv;
    order : fv;
  };

/**
 * Reference ECDSA signature algorithm as formalized from [ANSI X9.62-2005, pg 8]
 * Parameters:
 *  Curve c
 *  Private key d of signatory.
 *  Integer e obtained after hashing message on step e)
 *  Ephemeral EC private key in range [1 .. c.curve)
 */
ref_ecdsa_sign : {fv} (fin fv, fv >= 1) => (Curve [fv], [fv], [fv], [fv]) -> ([fv], [fv]);
ref_ecdsa_sign(c,d,e,k) = if is_zero(r) | is_zero(s) then (0,0) else (r, s)
  where {
    add(x,y) = ref_prime_add(c.order, x, y);
    mul(x,y) = safe_mod(c.order, safe_product(x, y));
    div(x,y) = ref_prime_div(c.order, x, y);
    is_zero(x) = c.field.is_equal(x, c.field.field_zero);
    /* Compute x coordinate of public key. */
    j = (ec_affinify(c.field, ec_ref_mul(c.field, k, c.base))).x;
    /* c) Set r = j mod n */
    r = safe_mod(c.order, j);
    s = div(add(e, mul(d, r)), k);
  };

/**
 * Reference ECDSA signature verification algorithm as formalized from [ANSI X9.62-2005, pg 9]
 * Parameters
 *  Curve c
 *  Integer e' obtained after hashing message on  step "c".
 *  Pair returned by ref_ecdsa_sign algorithm.
 *  Public key of key signatory.
 * Result:
 *  Bit that is True if verification suceeds, and false otherwise.
 */
ref_ecdsa_public_verify : {fv} (fin fv, fv >= 4) => (Curve [fv], [fv], ([fv], [fv]), AffinePoint [fv]) -> Bit;
ref_ecdsa_public_verify(c, e, (r, s), q)
    /* h) Compare v and r' if v = r', output "valid"; otherwise output "invalid". */
   = in_range(s) & (v == r)
  where {
    mul(x,y) = safe_mod(c.order, safe_product(x, y));
    div(x,y) = ref_prime_div(c.order, x, y);
    in_range(x) = (0 < x) & (x < c.order);
    s_inv = div(1, s);
    u1 = mul(e, s_inv);
    u2 = mul(r, s_inv);
    r2 = ec_ref_twin_mul(c.field, c.order, u1, c.base, u2, q);
    /* f) Convert the field element x_r to an integer j as described in A.5 */
    f = c.field;
    j = f.mul(r2.x, f.sq(f.div(f.field_unit, r2.z)));
    /* g) v = j mod n */
    v = safe_mod(c.order, j);
  };

/* P384 reference definitions {{{1 */

p384_prime : [384];
p384_prime = - (2 ** 384 + 2 ** 128 + 2 ** 96 - 2 ** 32 + 1);

// P384 field reference modulus.
ref_p384_mod : [768] -> [384];
ref_p384_mod(a)
    = take(384,
           if b1 then r 
           else if b2 then r1
           else if b3 then r2
           else if b4 then r3
           else r4)
  where {
    [ a0  a1  a2  a3  a4  a5  a6  a7  a8  a9 a10 a11
     a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23]
       = split a;
    z32 = zero : [32];
    z64 = zero : [64];
    p = p384_prime # z32;
    t  =  a0 #  a1 #  a2 #  a3 #  a4 #  a5 #  a6 #  a7 #  a8 #  a9 # a10 # a11 # z32;
    s1 =     (zero : [128])    # a21 # a22 # a23 #      (zero : [160])         # z32;
    s2 = a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # a21 # a22 # a23 # z32;
    s3 = a21 # a22 # a23 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # z32; 
    s4 = z32 # a23 # z32 # a20 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # z32;
    s5 =     (zero : [128])    # a20 # a21 # a22 # a23 #    (zero : [128])     # z32;
    s6 = a20 #    z64    # a21 # a22 # a23 #          (zero : [192])           # z32;
    d1 = a23 # a12 # a13 # a14 # a15 # a16 # a17 # a18 # a19 # a20 # a21 # a22 # z32;
    d2 = z32 # a20 # a21 # a22 # a23 #              (zero : [224])             # z32;
    d3 =  (zero : [96])  # a23 # a23 #              (zero : [224])             # z32;
    d1' = p - d1;
    r = t + (s1 << 1) + s2 + s3 + s4 + s5 + s6 + d1' - d2 - d3;
    (r1,b1) = ref_sbb(r, p);
    (r2,b2) = ref_sbb(r1, p);
    (r3,b3) = ref_sbb(r2, p);
    (r4,b4) = ref_sbb(r3, p);
   };

// Give explicit names to these finite field operators, so SBV
//  can uninterpret them.
ref_p384_is_val        = is_normal p384_prime;
ref_p384_add(x,y)      = ref_prime_add(p384_prime, x, y);
ref_p384_sub(x,y)      = ref_prime_sub(p384_prime, x, y);
/* ref_p384_neg(x) returns -x mod p384_prime. */
ref_p384_neg(x)        = if x == 0 then 0 else (p384_prime - x);
ref_p384_mul(x,y)      = ref_p384_mod(safe_product(x, y));
ref_p384_sq(x)         = ref_p384_mod(safe_product(x, x));
ref_p384_cube(x)       = ref_p384_mul(x, ref_p384_sq(x));
ref_p384_half(x)       = if even(x) then x >> 1
                         else drop(1, safe_add(x, p384_prime))
                         where { even x = take(1, x) == 0; };
ref_p384_div(x,y)      = ref_prime_div(p384_prime, x, y);
ref_p384_is_equal : ([384],[384]) -> Bit;
ref_p384_is_equal(x,y) = x == y;

type RsltWithCarry = { carry : [32]; rslt : [384] };
ref_p384_incFieldPrime : [384] -> RsltWithCarry;
ref_p384_incFieldPrime x = {carry = [(bs ! 0)] # zero; rslt = take(384, bs)}
  where bs = safe_add(x, p384_prime);
ref_p384_decFieldPrime : [384] -> RsltWithCarry;
ref_p384_decFieldPrime x = { carry = if (bs ! 0) then -1 else 0; rslt = take(384, bs)}
  where bs = safe_sub(x, p384_prime);

ref_p384_prime_div : ([384],[384],[384]) -> [384];
ref_p384_prime_div (p,x,y) = ref_prime_div(p,x,y);

/* Defines a reference prime field that uses normalized numbers and
   large word bit operations. */
ref_p384_field :  Field [384];
ref_p384_field = {
    is_val     = ref_p384_is_val;
    add        = ref_p384_add;
    sub        = ref_p384_sub;
    neg        = ref_p384_neg;
    mul        = ref_p384_mul;
    sq         = ref_p384_sq;
    half       = ref_p384_half;
    div        = ref_p384_div;
    field_unit = 1;
    field_zero = 0;
    is_equal   = ref_p384_is_equal;
    };


p384_ref_base : AffinePoint [384];
p384_ref_base = nzAffinePoint(
  join(reverse
       [0xaa87ca22 0xbe8b0537 0x8eb1c71e 0xf320ad74 0x6e1d3b62 0x8ba79b98
        0x59f741e0 0x82542a38 0x5502f25d 0xbf55296c 0x3a545e38 0x72760ab7]),
  join(reverse
       [0x3617de4a 0x96262c6f 0x5d9e98bf 0x9292dc29 0xf8f41dbd 0x289a147c
        0xe9da3113 0xb5f0b8c0 0x0a60b1ce 0x1d7e819d 0x7a431d7c 0x90ea0e5f]));


p384_ref_curve : Curve [384];
p384_ref_curve = {
    field = ref_p384_field;
    base = p384_ref_base;
    order = 
      join(reverse 
        [0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff
         0xc7634d81 0xf4372ddf 0x581a0db2 0x48b0a77a 0xecec196a 0xccc52973]);
  };

p384_ref_zero_point : JacobianPoint [384];
p384_ref_zero_point = ec_zero_point(ref_p384_field);

p384_ref_add : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384];
p384_ref_add(p,q) = ec_add(ref_p384_field, p, q);

p384_ref_double : JacobianPoint [384] -> JacobianPoint [384];
p384_ref_double(p) = ec_double(ref_p384_field, p);

p384_ref_full_add : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384];
p384_ref_full_add(p,q) = ec_full_add(ref_p384_field, p, q);

p384_ref_full_sub : (JacobianPoint [384],AffinePoint [384]) -> JacobianPoint [384];
p384_ref_full_sub(p,q) = ec_full_sub(ref_p384_field, p, q);

/* Manually inline
p384_ref_mul : ([384], AffinePoint [384]) -> JacobianPoint [384];
p384_ref_mul(x,p) = ec_ref_mul(ref_p384_field, x, p);
*/
/*
p384_ref_mul : ([384], AffinePoint [384]) -> JacobianPoint [384];
p384_ref_mul (d, s) = res@(384+1)
  where {
    k = d # [False False];
    h = k + (k + k);
    res : [inf](JacobianPoint [384]);
    res = [p384_ref_zero_point]
          #  [| if hi & ~ki then
                  p384_ref_full_add(p384_ref_double(r), s)
                else if ~hi  & ki then
                  p384_ref_full_sub(p384_ref_double(r), s)
                else
                  p384_ref_double(r)
             || hi <- reverse(h) # zero
             || ki <- reverse(k) # zero
             || r  <- res |];
    };
*/

/* Matches Java implementation */
p384_ref_mul_aux : ( JacobianPoint [384]
                   , AffinePoint [384]
                   , [32], [32], [32] ) -> JacobianPoint [384];
p384_ref_mul_aux (r, s, m, hi, ki) = r'
  where {
    r'' = p384_ref_double(r);
    r' = if ((hi & m) != zero) & ((ki & m) == zero) then
           p384_ref_full_add(r'', s)
         else if ((hi & m) == zero) & ((ki & m) != zero) then
           p384_ref_full_sub(r'', s)
         else r'';
  };

/* Matches Java implementation */
p384_ref_mul : ([384], AffinePoint [384]) -> JacobianPoint [384];
p384_ref_mul (d, s) = (res @ 384)
  where {
    d' : [12][32];
    d' = split d;
    (h, c) = ripple_adc(d', ripple_shr(d', False));
    r0 = if c
          then ec_projectify(ref_p384_field, s)
          else p384_ref_zero_point;
    f (j, r) = p384_ref_mul_aux(r, s, 1 << j, h @ i, ki')
      where {
        i = j >> 5;
        ki = (d' @ i) >> 1;
        ki' = if i < 11 then ki | (((d' @ (i+1)) & 1) << 31) else ki;
      };
    res = [r0] #
          [| f(j, r)
          || j <- mk_strm (reverse [0..383])
          || r <- res
          |]
  };

p384_ref_ecdsa_sign : ([384], [384], [384]) -> ([384],[384]);
p384_ref_ecdsa_sign(d,e,k) = ref_ecdsa_sign(p384_ref_curve,d,e,k);

/* P384 test code {{{2 */

/* Curve "a" parameter, defined in [FIPS-186-3, page 87] to be -3 */
p384_a : [384];
p384_a = p384_prime - 3;

/* Curve "b" parameter, defined in [FIPS-186-3, page 89] */
p384_b : [384];
p384_b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef;

/* Point "S" defined in [NSA 2008, Section 4.4.2] */
p384_s : AffinePoint [384];
p384_s = nzAffinePoint(
  join(reverse
        [0xfba203b8 0x1bbd23f2 0xb3be971c 0xc23997e1 0xae4d89e6 0x9cb6f923
         0x85dda827 0x68ada415 0xebab4167 0x459da98e 0x62b1332d 0x1e73cb0e]),
  join(reverse
        [0x5ffedbae 0xfdeba603 0xe7923e06 0xcdb5d0c6 0x5b223014 0x29293376
         0xd5c6944e 0x3fa6259f 0x162b4788 0xde6987fd 0x59aed5e4 0xb5285e45]));

/* Point "T" defined in [NSA 2008, Section 4.4.2] */
p384_t : AffinePoint [384];
p384_t = nzAffinePoint(
  join(reverse
        [0xaacc0520 0x2e7fda6f 0xc73d82f0 0xa6622052 0x7da8117e 0xe8f8330e
         0xad7d20ee 0x6f255f58 0x2d8bd38c 0x5a7f2b40 0xbcdb68ba 0x13d81051]),
  join(reverse
        [0x84009a26 0x3fefba7c 0x2c57cffa 0x5db3634d 0x286131af 0xc0fca8d2
         0x5afa22a7 0xb5dce0d9 0x470da892 0x33cee178 0x592f49b6 0xfecb5092]));

/* Multiple "D" defined in [NSA 2008, Section 4.4.2] */
p384_d =
  join(reverse
        [0xa4ebcae5 0xa6659834 0x93ab3e62 0x6085a24c 0x104311a7 0x61b5a8fd
         0xac052ed1 0xf111a5c4 0x4f76f456 0x59d2d111 0xa61b5fdd 0x97583480]);

/* Multiple "E" defined in [NSA 2008, Section 4.4.2] */
p384_e =
  join(reverse
        [0xafcf8811 0x9a3a76c8 0x7acbd600 0x8e1349b2 0x9f4ba9aa 0x0e12ce89
         0xbcfcae21 0x80b38d81 0xab8cf150 0x95301a18 0x2afbc689 0x3e75385d]);

/* Convert a p384 Jacobian point to an affine point */
p384Affinify : JacobianPoint [384] -> AffinePoint [384];
p384Affinify p = ec_affinify(ref_p384_field,p);

/* Convert a p384 affine point to a Jacobian point */
p384Jacobify : AffinePoint [384] -> JacobianPoint [384];
p384Jacobify p = { x = p.x; y = p.y; z = 1 };

/* Does an affine point lie on the curve? */
p384IsAffinePoint : AffinePoint [384] -> Bit;
p384IsAffinePoint p =
  ref_p384_sq(p.y) ==
  ref_p384_add(ref_p384_cube(p.x),
               ref_p384_add(ref_p384_mul(p384_a,p.x),
                            p384_b));

/* P384 implementation curve definition {{{1 */

/* Chunked arithmetic routines {{{2 */

/* Return second element of each pair */
fst : {m n} (m,n) -> m;
fst(x,y) = x;

/* Return second element of each pair */
snd : { m n } (m,n) -> n;
snd(x,y) = y;

/* Promote a finite sequence to an infinite sequence */
mk_strm : {a b} fin a => [a][b] -> [inf][b];
mk_strm x = x # zero;

/* Adds two n*m bit numbers split into m-bit segments and returns carry. */
ripple_adc : {m  n} (m >= 1, fin m, fin n) => ([n][m],[n][m]) -> ([n][m],Bit);
ripple_adc(xx,yy) = (values, carry_strm @ (width xx))
  where {
    adc(x,y,c) = (take(width x,sum), sum @ width x)
      where sum = safe_add(x,y) + uext([c]);
    list_strm = [| adc(a,b,c)
           || a <- mk_strm xx
           || b <- mk_strm yy
           || c <- carry_strm
           |];
    list = take(width xx,list_strm);
    values = [| v || (v,_) <- list |];
    carry_strm  = [False] # [| c || (_,c) <- list_strm |];
  };

/* Subtracts two n*m bit numbers split into m-bit segments and returns borrow. */
ripple_sbb : {m  n} (m >= 1, fin m, fin n) => ([n][m],[n][m]) -> ([n][m],Bit);
ripple_sbb(xx,yy) = (values, borrow!0)
  where {
    sbb(x,y,b) = (take(width x,d), ~ (d @ width x))
      where d = (x # [True]) - (y # [False]) - uext([b]);
    list = [| sbb(a,b,c)
           || a <- xx
           || b <- yy
           || c <- borrow
           |];
    values = [| v || (v,_) <- list |];
    borrow  = [False] # [| c || (_,c) <- list |];
  };

ripple_sub : {m n} (m >= 1, fin m, fin n) => ([n][m],[n][m]) -> [n][m];
ripple_sub(x,y) = fst(ripple_sbb(x,y));

/* ripple_lt(x,y) returns true if x is less than y. */
ripple_lt : {m n} (fin m, fin n) => ([n][m],[n][m]) -> Bit;
ripple_lt(xl,yl) = rl!0
  where
    rl = [ False ]
       # [| (x < y) | ((x == y) & r)
         || x <- xl
         || y <- yl
         || r <- rl
         |];

/* Add two numbers in normalized form. */
imp_prime_add : {m n} (m >= 1,fin m,fin n) => ([n][m],[n][m],[n][m]) -> [n][m];
imp_prime_add(p,x,y) = if c1 | ~c2 then r2 else r1
  where {
    (r1,c1) = ripple_adc(x, y);
    (r2,c2) = ripple_sbb(r1, p);
  };

/* Subtract two numbers in normalized form. */
imp_prime_sub : {m n} (m >= 1, fin m, fin n) => ([n][m], [n][m],[n][m]) -> [n][m];
imp_prime_sub(p,x,y) = if b then r2 else r1
  where {
    (r1,b) = ripple_sbb( x, y);
    (r2,_) = ripple_adc(r1, p);
  };

imp_p384_prime : [12][32];
imp_p384_prime = split p384_prime;

/* Multiply two chunked numbers and return product. */
imp_product : {m n} (m >= 1, fin m, n >= 1, fin n) => ([n][m],[n][m]) -> [2*n][m];
imp_product(xl,yl) = al!0
  where {
    scalar_mult : ([m],[n][m]) -> ([n+1][m]);
    scalar_mult(x,yl) = vl # [final]
      where {
        rl : [n][2][m];
        rl = [| split(uext(c) + safe_product(x,y))
             || y <- yl
             || [_ c] <- rl >> 1 
             |];
        vl = [| rv || [rv _] <- rl |];
        [_ final] = rl!0;
      };
    al = [(zero)]
       # [| fst(ripple_adc(a, (scalar_mult(x,yl) # zero) >> i))
         || a <- al
         || x <- xl
         || i <- [0 .. ] |];
  };

/* Returns (xl # c) >> 1. */
ripple_shr : {m n} (m >= 1, fin m, n >= 1, fin n) => ([n][m],Bit) -> ([n][m]);
ripple_shr(xl,c) = [| (x' << (width(x) - 1)) | (x >> 1)
                   || x <- xl
                   || x' <- drop(1,xl) # [(uext([c]))] |];

imp_prime_half : {m n} (m >= 1, fin m, n >= 1, fin n) => ([n][m],[n][m]) -> ([n][m]);
imp_prime_half(x, p) = ripple_shr(if ~(x@0@0) then (x,False) else ripple_adc(x,p));

/* Returns x/y in F_p using Euler's binary gcd algorithm. */
/* Taken from [HMV] */
imp_prime_div : {m n} (m >= 1, fin m, n >= 1, fin n) => ([n][m],[n][m],[n][m]) -> [n][m];
imp_prime_div(p,x,y) = egcd(p,zero,y,x)
  where {
    even xl = ~(xl@0@0);
    half x = ripple_shr(x,False);
    /* In code below, a is always odd. */
    egcd(a,ra,b,rb) =
      if b == zero then
        ra
      else 
        egcd(if even(b) then
               (a, ra, half(b), imp_prime_half(rb, p))
             else if ripple_lt(a, b) then
               (a, ra, half(ripple_sub(b, a)), imp_prime_half(imp_prime_sub(p, rb, ra), p))
             else 
               (b, rb, half(ripple_sub(a, b)), imp_prime_half(imp_prime_sub(p, ra, rb), p)));
  };

/* The previous algorithm specialized to 384 bits, but not specialized
 * to a specific prime, because that's how the Java implementation is
 * structured. */

/* We separate the key computation from the recursive combinator. */
/* In code below, a is always odd. */
imp_p384_egcd_step : ([12][32], [12][32], [12][32], [12][32], [12][32]) ->
                     ([12][32], [12][32], [12][32], [12][32], [12][32]);
imp_p384_egcd_step(a,ra,b,rb,p) =
  if even(b) then
    (a, ra, half(b), imp_prime_half(rb, p), p)
  else if ripple_lt(a, b) then
    (a, ra, half(ripple_sub(b, a)),
     imp_prime_half(imp_prime_sub(p, rb, ra), p), p)
  else
    (b, rb, half(ripple_sub(a, b)),
     imp_prime_half(imp_prime_sub(p, ra, rb), p), p)
  where {
    even xl = ~(xl@0@0);
    half x = ripple_shr(x,False);
  };

/* In code below, a is always odd. */
imp_p384_egcd : ([12][32], [12][32], [12][32], [12][32], [12][32]) -> [12][32];
imp_p384_egcd(a,ra,b,rb,p) =
  if b == zero then
    ra
  else
    imp_p384_egcd(imp_p384_egcd_step(a, ra, b, rb, p));

imp_prime_384_div : ([12][32],[12][32],[12][32]) -> [12][32];
imp_prime_384_div(p,x,y) = imp_p384_egcd(p,zero,y,x,p);

theorem imp_prime_div_correct: {p x y}.
  imp_prime_384_div (p, x, y) == imp_prime_div (p, x, y);

/********************
   REVISIT:
     With the definition of imp_p384_mod below,
     QuickCheck can find counterexamples to this theorem:

     theorem imp_p384_mod_correct : {a1}.
       imp_p384_mod a1 == split (safe_mod (p384_prime, join a1));

     For now, we're just using the (appropriately coerced)
     ref_p384_mod algorithm for the imp_p384_mod. We'll debug
     the real algorithm when we start proving the correctness
     of the other finite field operations.

imp_p384_mod : [24][32] -> [12][32];
imp_p384_mod(al)
    = if of!0 then 
        /* if of is negative */
        fst(ripple_adc(r,imp_p384_prime))
      else t
  where {
    [ a0  a1  a2  a3  a4  a5  a6  a7  a8  a9 a10 a11
     a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23] 
     = [| uext(a) : [64] || a <- al |];

    [ r0  r0c] = split(              a0              + a12 + a21       + a20       - a23);
    [ r1  r1c] = split(iext( r0c) +  a1              + a13 + a22 + a23             - a12 - a20);
    [ r2  r2c] = split(iext( r1c) +  a2              + a14 + a23                   - a13 - a21);
    [ r3  r3c] = split(iext( r2c) +  a3              + a15 + a12 + a20 + a21       - a14 - a22 - a23);
    [ r4  r4c] = split(iext( r3c) +  a4 + (a21 << 1) + a16 + a13 + a12 + a20 + a22 - a15);
    [ r5  r5c] = split(iext( r4c) +  a5 + (a22 << 1) + a17 + a14 + a13 + a21 + a23 - a16);
    [ r6  r6c] = split(iext( r5c) +  a6 + (a23 << 1) + a18 + a15 + a14 + a22       - a17);
    [ r7  r7c] = split(iext( r6c) +  a7              + a19 + a16 + a15 + a23       - a18);
    [ r8  r8c] = split(iext( r7c) +  a8              + a20 + a17 + a16             - a19);
    [ r9  r9c] = split(iext( r8c) +  a9              + a21 + a18 + a17             - a20);
    [r10 r10c] = split(iext( r9c) + a10              + a22 + a19 + a18             - a21);
    [r11 r11c] = split(iext(r10c) + a11              + a23 + a20 + a19             - a22);
      r = [r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11];
     /* Overflow value of previous sums */
     of = uext(r11c) : [64];
    [ s0  s0c] = split(             uext( r0) + of);
    [ s1  s1c] = split(iext( s0c) + uext( r1) - of);
    [ s2  s2c] = split(iext( s1c) + uext( r2));
    [ s3  s3c] = split(iext( s2c) + uext( r3) + of);
    [ s4  s4c] = split(iext( s3c) + uext( r4) + of);
    [ s5  s5c] = split(iext( s4c) + uext( r5));
    [ s6  s6c] = split(iext( s5c) + uext( r6)) : [2][32];
    [ s7  s7c] = split(iext( s6c) + uext( r7));
    [ s8  s8c] = split(iext( s7c) + uext( r8)) : [2][32];
    [ s9  s9c] = split(iext( s8c) + uext( r9));
    [s10 s10c] = split(iext( s9c) + uext(r10)) : [2][32];
    [s11 s11c] = split(iext(s10c) + uext(r11));
      s = if of == 0 then
               r
          else [s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11];
      t = if (s11c != 0) | ripple_lt(imp_p384_prime,s) then
            ripple_sub(s, imp_p384_prime)
          else
            s
   };

********************/

// p384 bitvector embedding and projection.

p384_emb : [12][32] -> [384];
p384_emb = join;

p384_prj : [384] -> [12][32];
p384_prj = split;

// EP-pair between p384 bitvector types.
p384_ep : EP ([12][32], [384]);
p384_ep = EP p384_emb p384_prj;

p384_ep_op : EP_OP ([12][32], [384]);
p384_ep_op = ep_op p384_ep;

// REVISIT:
//   Dummy version of imp_p384_mod. See "REVISIT" note
//   in the commented-out definition of imp_p384_mod above.
imp_p384_mod : [24][32] -> [12][32];
imp_p384_mod = Hom_mor join split ref_p384_mod;

// Give explicit names to these finite field operators, so SBV
//  can uninterpret them.
imp_p384_is_val(x)     = is_normal p384_prime (join x);
imp_p384_add(x,y)      = imp_prime_add(imp_p384_prime, x, y);
imp_p384_sub(x,y)      = imp_prime_sub(imp_p384_prime, x, y);
/* imp_p384_neg(x) returns -x mod p384_prime. */
imp_p384_neg(x)        = if x == zero then zero
                         else ripple_sub(imp_p384_prime, x);
imp_p384_mul(x,y)      = imp_p384_mod(imp_product(x, y));
imp_p384_sq(x)         = imp_p384_mod(imp_product(x, x));
imp_p384_half(x)       = imp_prime_half(x, imp_p384_prime);
imp_p384_div(x,y)      = imp_prime_div(imp_p384_prime, x, y);
imp_p384_is_equal(x,y) = x == y;

/* Defines a reference prime field that uses normalized numbers and
   large word bit operations. */
imp_p384_field :  Field [12][32];
imp_p384_field = {
    is_val     = imp_p384_is_val;
    add        = imp_p384_add;
    sub        = imp_p384_sub;
    neg        = imp_p384_neg;
    mul        = imp_p384_mul;
    sq         = imp_p384_sq;
    half       = imp_p384_half;
    div        = imp_p384_div;
    field_unit = [1] # zero;
    field_zero = zero;
    is_equal   = imp_p384_is_equal;
  };

map_point : {a b} (a -> b, JacobianPoint a) -> JacobianPoint b;
map_point(fn, p) = { x = fn(p.x); y = fn(p.y); z = fn(p.z) };

test : JacobianPoint [12][32] -> Bit;
test p 
  = ec_double(ref_p384_field, map_point(join,p)) == map_point(join, ec_double(imp_p384_field, p));



