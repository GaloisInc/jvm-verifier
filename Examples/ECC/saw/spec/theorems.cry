include "ecc.cry";

theorem mul_java_ok: {a x y}. mul_java(a, x,y) == safe_product(x,y);

theorem sq_java_ok: {a x}. sq_java(a, x) == safe_product(x,x);

theorem group_mul_good: {x y}.
  p384_group_mul(p384_group_size, x, y) == mod_mul(p384_group_size, x, y);

//theorem p384_ec_twin_mul_candidate2_ok: {x p y q}. ok1 & ok2 & ok3 where (_, ok1, ok2, ok3) = p384_ec_twin_mul_candidate2(x,p,y,q);
// theorem p384_ec_twin_mul_candidate2_good: {x p y q}. p384_ec_twin_mul(x,p,y,q) == p384_ec_twin_mul_candidate2(x,p,y,q);

//theorem p384_ec_twin_mul_candidate3_ok : {x p y q}. 
//  p384_ec_twin_mul(x,p,y,q) == ec_twin_mul(p384_point_ops,x,p,y,q);

//theorem p384_ec_twin_mul_candidate3_ok : {x p y q}. 
//  p384_ec_twin_mul_candidate3(x,p,y,q) == p384_ec_twin_mul(x,p,y,q);
//p384_ec_twin_mul : ([384], AffinePoint [384], [384], AffinePoint [384]) -> (JacobianPoint [384]);
//p384_ec_twin_mul(x,p,y,q) = ec_twin_mul(p384_point_ops, x, p, y, q);

//theorem ec_twin_mul_with_aux1_ok : {x p y q}. 
//  ec_twin_mul_orig(p384_point_ops, x, p, y, q) == p384_ec_twin_mul(x, p, y, q);

// This one actually isn't true! Takes a long time to run, but is
// falsifiable. However, we haven't done a proof of equivalence with the
// Java code yet, either.
/*
theorem p384_ec_mul_window_ok: {d s}.
  p384_ec_mul_window_top (d, s) == p384_ec_mul(d, s);
*/
