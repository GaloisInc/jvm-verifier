// Define operators from SBV files.
extern SBV is_field("sbv-old/ref_p384_is_val.sbv")  : [384] -> Bit;
extern SBV field_add("sbv-old/ref_p384_add.sbv") : ([384],[384]) -> [384];
extern SBV field_sub("sbv-old/ref_p384_sub.sbv") : ([384],[384]) -> [384];
extern SBV field_mul("sbv-old/ref_p384_mul.sbv") : ([384],[384]) -> [384];
extern SBV field_mod("sbv-old/ref_p384_mod.sbv") : [768] -> [384];
extern SBV field_sq("sbv-old/ref_p384_sq.sbv") : [384] -> [384];
extern SBV ec_double("sbv-old/p384_ref_double.sbv") :
  { x: [384]; y: [384]; z: [384] } -> { x:[384]; y:[384]; z:[384] };
extern SBV field_half("sbv-old/ref_p384_half.sbv") : [384] -> [384];
extern SBV field_neg("sbv-old/ref_p384_neg.sbv") : [384] -> [384];
extern SBV ec_full_add("sbv-old/p384_ref_full_add.sbv") :
  ({ x: [384]; y: [384]; z: [384] }, { x:[384]; y:[384] }) ->
  { x:[384]; y:[384]; z:[384] };
extern SBV ec_full_sub("sbv-old/p384_ref_full_sub.sbv") :
  ({ x: [384]; y: [384]; z: [384] }, { x:[384]; y:[384] }) ->
  { x:[384]; y:[384]; z:[384] };
extern SBV ec_mul_aux("sbv-old/p384_ref_mul_aux.sbv") :
  ({ x: [384]; y: [384]; z: [384] }, { x:[384]; y:[384] }, [32], [32], [32]) ->
  { x:[384]; y:[384]; z:[384] };
extern SBV ec_mul("sbv-old/p384_ref_mul.sbv") :
  ([384], { x:[384]; y:[384] }) -> { x:[384]; y:[384]; z:[384] };

// Define field prime for P384 curve (taken from NIST and NSA documents).
let field_prime = <| 2^384 - 2^128 - 2^96 + 2^32 - 1 |> : [384];

// Array operation verification {{{1

method com.galois.ecc.P384ECC64.is_zero {
  var args[0] :: int[12];
  return if join(valueOf(args[0])) == 0:[384] then 1:[32] else 0:[32];
  verify abc;
};

method com.galois.ecc.P384ECC64.set_zero {
  var args[0] :: int[12];
  ensure valueOf(args[0]) := split(0:[384]) : [12][32];
  verify abc;
};

method com.galois.ecc.P384ECC64.set_unit {
  var args[0] :: int[12];
  ensure valueOf(args[0]) := split(1:[384]) : [12][32];
  verify abc;
};

method com.galois.ecc.P384ECC64.assign {
  var args[0], args[1] :: int[12];
  ensure valueOf(args[0]) := valueOf(args[1]);
  verify abc;
};

// Field operation verification {{{1

// field_add {{{2
//
// field_add takes three valueOfs as arguments: args[0], args[1], and args[2].
// To avoid allocating memory, it stores the result of adding args[1] and args[2]
// into the first argument "args[0]".
method com.galois.ecc.P384ECC64.field_add {
  // Simulator types for references must give explicit length for valueOfs.

  // Note: If debugging information is available, we could eventually support
  // using the argument names from the Java debugging information.  However, for
  // our initial release, arguments must be refered to by position.
  var args[0], args[1], args[2] :: int[12];
  var this.field_prime :: int[12];

  // Allow any of the valueOfs to alias the other valueOfs.
  // Complicates verification, but necessary for correctness of higher-level
  // operations such as "ec_double".
  mayAlias { args[0], args[1], args[2] };

  // Require Java this.field_prime field equals SAWScript field_prime constant.
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  // Result of executing method.
  // In this case, we store the result of adding args[1] and args[2] inside of
  // args[0].
  ensure valueOf(args[0]) := 
    split(field_add(join(valueOf(args[1])), join(valueOf(args[2])))) : [12][32];

  quickcheck 100;
};

// field_sub {{{2

method com.galois.ecc.P384ECC64.field_sub {
  var args[0], args[1], args[2] :: int[12];
  var this.field_prime :: int[12];
  mayAlias { args[0], args[1], args[2] };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  ensure valueOf(args[0]) :=
    split(field_sub(join(valueOf(args[1])), join(valueOf(args[2])))) : [12][32];
  verify abc;
};

// field_dbl {{{2

method com.galois.ecc.P384ECC64.field_dbl {
  var args[0], args[1] :: int[12];
  var this.field_prime :: int[12];
  mayAlias { args[0], args[1] };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jarg1 = join(valueOf(args[1]));
  ensure valueOf(args[0]) := split(field_add(jarg1, jarg1)) : [12][32];
  verify abc;
};

// field_dbl_dec {{{2

rule eq_elim : forAll {x:a}. x == x -> True;

rule join_split : forAll {x:[384]}.
  join(split(x) : [12][32]) -> x;

method com.galois.ecc.P384ECC64.field_dbl_dec {
  var args[0], args[1] :: int[12];
  var this.field_prime :: int[12];
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  // Require that args[0] and args[1] are valid field elements.
  // assert is_field(join(valueOf(args[0])));
  // assert is_field(join(valueOf(args[1])));

  let jarg0 = join(valueOf(args[0]));
  let jarg1 = join(valueOf(args[1]));
  ensure valueOf(args[0]) := split(field_sub(field_sub(jarg0, jarg1), jarg1)) : [12][32];
  verify rewrite;
};

// field_mul3 {{{2

method com.galois.ecc.P384ECC64.field_mul3 {
  // Require arguments are 12-element integer valueOfs.
  var args[0], args[1] :: int[12];
  var this.field_prime :: int[12];

  // Require Java this.field_prime field equals SAWScript field_prime constant.
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  // assert is_field(join(valueOf(args[0])));
  // assert is_field(join(valueOf(args[1])));

  // Let jarg1 equals args[1] value as a single 384-bit number.
  let jarg1 = join(valueOf(args[1]));

  // Store result of jarg1 + jarg1 + jarg1 inside first argument valueOf.
  ensure valueOf(args[0]) := split(field_add(jarg1, field_add(jarg1, jarg1))) : [12][32];

  verify abc;
};

// field_mul4 {{{2
method com.galois.ecc.P384ECC64.field_mul4 {
  var args[0], args[1] :: int[12];
  var this.field_prime :: int[12];
  mayAlias { args[0], args[1] };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jarg1 = join(valueOf(args[1]));
  let dbl = field_add(jarg1, jarg1);
  ensure valueOf(args[0]) := split(field_add(dbl, dbl)) : [12][32];
  verify abc;
};

// field_mul8 {{{2
method com.galois.ecc.P384ECC64.field_mul8 {
  var args[0], args[1] :: int[12];
  var this.field_prime :: int[12];
  mayAlias { args[0], args[1] };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jarg1 = join(valueOf(args[1]));
  let dbl = field_add(jarg1, jarg1);
  let quad = field_add(dbl, dbl);
  ensure valueOf(args[0]) := split(field_add(quad, quad)) : [12][32];
  verify abc;
};

// field_red {{{2
method com.galois.ecc.P384ECC64.field_red {
  var args[0] :: int[12];
  var args[1] :: int[24];
  var this.field_prime :: int[12];

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  ensure valueOf(args[0]) := split(field_mod(join(valueOf(args[1])))) : [12][32];

  quickcheck 100;
};

// field_mul {{{2
method com.galois.ecc.P384ECC64.field_mul {
  // Require arguments are 12-element integer valueOfs.
  var args[0], args[1], args[2] :: int[12];
  // Require "this.a" is a temporary buffer capable of storing 24 integers.
  var this.a :: int[24];
  var this.field_prime :: int[12];

  // Allow three arguments to alias.
  mayAlias { args[0], args[1], args[2] };

  // Require that args[1] and args[2] are valid field elements.
  // assert is_field(join(valueOf(args[1])));
  // assert is_field(join(valueOf(args[2])));

  // Require Java this.field_prime field equals SAWScript field_prime constant.
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  // Store result of args[1] * args[2] inside args[0].
  ensure valueOf(args[0]) := split(field_mul(join(valueOf(args[1])), join(valueOf(args[2])))) : [12][32];

  // Indicate that the value of this.a after execution may be an arbitrary value.
  // This is implemented in symbolic simulator by creating a new fresh variable
  // after executing field_mul.
  modify valueOf(this.a);

  // Test field_mul using quickcheck.
  //verify quickcheck 100;
};

// field_sq {{{2
method com.galois.ecc.P384ECC64.field_sq {
  var args[0], args[1] :: int[12];
  var this.a :: int[24];
  var this.field_prime :: int[12];
  mayAlias { args[0], args[1] };
  // assert is_field(join(valueOf(args[1])));
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  ensure valueOf(args[0]) := split(field_mul(join(valueOf(args[1])), join(valueOf(args[1])))) : [12][32];
  modify valueOf(this.a);
};

// mod_half {{{2
method com.galois.ecc.P384ECC64.mod_half {
  var args[0] :: int[12];
  var args[1] :: int[12];
  // assert that second argument is field_prime;
  assert valueOf(args[1]) := split(field_prime) : [12][32];
  ensure valueOf(args[0]) := split(field_half(join(valueOf(args[0])))) : [12][32];
  verify abc;
};

// mod_div {{{2
method com.galois.ecc.P384ECC64.mod_div {
  var args[0], args[1], args[2], args[3] :: int[12];
  var this.t1, this.t2, this.t3 :: int[12];
  //var locals[swapped] :: bool;
  var locals[a], locals[ra], locals[b], locals[rb] :: int[12];

  ensure valueOf(args[0]) 
    := valueOf(args[0]);
       /*
       split(p384_prime_div(join(valueOf(args[3])),
                            join(valueOf(args[1])),
                            join(valueOf(args[2])))) : [12][32];*/
  modify valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);

  at 44 {
    if (swapped == 0:[32]) {
      //assert swapped := false;
      assert locals[a] := this.t1;
      assert locals[ra] := args[0];
      assert locals[b] := this.t2;
      assert locals[rb] := this.t3;
    } else { 
      //assert swapped := true;
      assert locals[a] := this.t2;
      assert locals[ra] := this.t3;
      assert locals[b] := this.t1;
      assert locals[rb] := args[0];
    };
    ensure valueOf(args[0]) 
       := valueOf(args[0]);
          /*
          split(p384_egcd(join(valueOf(a)),
                          join(valueOf(ra)),
                          join(valueOf(b)),
                          join(valueOf(rb)))) : [12][32];*/
    modify valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  };

  /*
  verify {
    if (initialPC == 44) {
       expand p384_egcd(join(valueOf(a)),
                        join(valueOf(ra)),
                        join(valueOf(b)),
                        join(valueOf(rb)));
    }
    uninterpret p384_egcd;
    yices;
  };
  */
};

set verification on;

// Point operation verification {{{1

// Diable field operations.
//disable is_field;
//disable field_add;
//disable field_sub;

// Define rules for rewriting verification {{{2

// Strategies used in creating rewrite rules.
//   Push split and join towards bottom of terms.
//   Prefer join to split in equals.
//   Cancel unnessary applications wherever possible
//     with cancelation/elimination rules.

// Misc cancelation rules{{{3
rule not_not : forAll {x:Bit}.  not(not(x)) -> x;
rule eq_elim : forAll {x:a}. x == x -> True;

rule join_split : forAll {x:[384]}.
  join(split(x) : [12][32]) -> x;

// Boolean elimination rules {{{3

rule and_true_elim1 : forAll {x:Bit}. True && x -> x;
rule and_true_elim2 : forAll {x:Bit}. x && True -> x;
rule and_false_elim1 : forAll {x:Bit}. False && x -> False;
rule and_false_elim2 : forAll {x:Bit}. x && False -> False;
rule and_left_assoc : forAll {x:Bit, y:Bit, z:Bit}.
 x && (y && z) -> (x && y) && z;

rule or_true_elim1 : forAll {x:Bit}. True || x -> True;
rule or_true_elim1 : forAll {x:Bit}. x || True -> True;
rule or_false_elim1 : forAll {x:Bit}. False || x -> x;
rule or_false_elim2 : forAll {x:Bit}. x || False -> x;

// Move not inside {{{3
rule not_or : forAll {x:Bit, y:Bit}.
  not (x || y) -> not x && not y;
rule not_and : forAll {x:Bit, y:Bit}.
  not (x && y) -> not x || not y;

rule or_trivial : forAll {x:Bit}. not x || x -> True;

// Redundancy {{{3
rule or_redundant1 : forAll {x:Bit,y:Bit}. (x || y) || y -> x || y;
rule or_redundant2 : forAll {x:Bit,y:Bit}. (x || y) || x -> x || y;
rule and_redundant1 : forAll {x:Bit,y:Bit}. (x && y) && y -> x && y;
rule and_redundant2 : forAll {x:Bit,y:Bit}. (x && y) && x -> x && y;

// Generic ite rules {{{3
rule ite_not :
  forAll { b:Bit, x:a, y:a }.
    (if (not b) then x else y) -> if b then y else x;
rule ite_elim_1 : forAll { b:Bit, x:a, y:a, z:a }.
  (if b then (if b then x else y) else z)
  -> if b then x else z;
rule ite_elim_2 : forAll { b:Bit, x:a, y:a, z:a }.
  (if b then x else (if b then y else z))
  -> if b then x else z;
rule ite_bit : forAll {b:Bit, c:Bit, d:Bit}.
  if b then c else d -> (not b || c) && (b || d);

// Bit level ite rules {{{3
rule ite_bit_false_1 :
  forAll { b:Bit, c:Bit }.
    (if b then False else c) -> not b && c;

rule ite_bit_true_1 :
  forAll { b:Bit, c:Bit }.
    (if b then True else c) -> b || c;

// Eq-split rules{{{3

let zeroArray = split(0:[384]) : [12][32];
let unitArray = split(1:[384]) : [12][32];

rule eq_split_cong_1 : forAll {x:[384], y:[12][32]}.
  split(x):[12][32] == y -> x == join(y);
rule eq_split_cong_2 : forAll {x:[12][32], y:[384]}.
  x == split(y):[12][32] -> join(x) == y;

// Special purpose rules
// N.B. In the long term, it should be able to write more general rules
// than this.
rule eq_split_valueOf_zeroArray : forAll { x:[12][32]}.
  x == zeroArray -> join(x) == 0:[384];
rule eq_split_valueOf_unitArray : forAll { x:[12][32]}.
  x == unitArray -> join(x) == 1:[384];

// ite congruence rules {{{3

rule ite_eq_cong_1 :
  forAll { b:Bit, x:a, y:a, z:a }.
    (if b then x else y) == z -> if b then (x == z) else (y == z);
rule ite_eq_cong_2 :
  forAll { b:Bit, x:a, y:a, z:a }.
    z == (if b then x else y) -> if b then (z == x) else (z == y);
rule ite_split_cong :
  forAll { b:Bit, x:[384], y:[384] }.
    split(if b then x else y) : [12][32] -> 
      if b then split(x) : [12][32] else split(y) : [12][32];
rule ite_join_cong :
  forAll { b:Bit, x:[12][32], y:[12][32] }.
    join(if b then x else y) -> 
      if b then join(x) else join(y);

// Record elimination rules {{{3

rule jacobianX :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.x -> x0;
rule jacobianY :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.y -> y0;
rule jacobianZ :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.z -> z0;

rule affineX :
  forAll { x0 : a, y0 : a }.
    { x = x0 ; y = y0 }.x -> x0;
rule affineY :
  forAll { x0 : a, y0 : a }.
    { x = x0 ; y = y0 }.y -> y0;


// Field-specific elimination rules {{{3

rule field_sq_def :
  forAll { x:[384] }.
   field_sq(x) -> field_mul(x, x);

rule ite_zero_field_mul :
  forAll { x:[384], y:[384], z:[384], c:Bit }.
    (if (x == 0:[384]) then (field_mul(x, y) == z:[384]) else c)
     -> (if (x == 0:[384]) then (z:[384] == 0:[384]) else c);

// }}}3

// ec_double {{{2
enable ec_double;
// Point doubling spec.
// Point doubling take a single Jacobian point and modify it's fields so that
// they refer to the point after it has been doubled.
// It uses some temporary buffers for storing results, but allocates no new memory.
method com.galois.ecc.P384ECC64.ec_double {
  // Indicate type for argument.
  var args[0] :: com.galois.ecc.JacobianPoint;
  // Indicate type for fields of Java JacobianPoint.
  var args[0].x, args[0].y, args[0].z :: int[12];
  // Provide types for temporary buffers.
  var this.a :: int[24];
  var this.t1, this.t2 :: int[12];

  // Require that fields for Jacobian point are valid field elements.
  // assert is_field(join(valueOf(args[0].x)));
  // assert is_field(join(valueOf(args[0].y)));
  // assert is_field(join(valueOf(args[0].z)));

  // Constants
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  // Let res denote the Cryptol struct formed from Cryptol ec_double operation.
  let res = ec_double({ x = join(valueOf(args[0].x)) ; y = join(valueOf(args[0].y)) ; z = join(valueOf(args[0].z)) });

  // Split results of Cryptol operation into Java fields.
  ensure valueOf(args[0].x) := split(res.x) : [12][32];
  ensure valueOf(args[0].y) := split(res.y) : [12][32];
  ensure valueOf(args[0].z) := split(res.z) : [12][32];

  // Indicate temporary buffers are modify.
  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2);

  // Use rewriting to verify ec_double.
  verify rewrite;
};
disable ec_double;

// ec_full_add {{{2
enable ec_full_add;
method com.galois.ecc.P384ECC64.ec_full_add {
  var args[0] :: com.galois.ecc.JacobianPoint;
  var args[1] :: com.galois.ecc.AffinePoint;
  var this.a :: int[24];
  var this.t1, this.t2, this.t3 :: int[12];
  var args[0].x, args[0].y, args[0].z :: int[12];
  var args[1].x, args[1].y :: int[12];
  assert is_field(join(valueOf(args[0].x)));
  assert is_field(join(valueOf(args[0].y)));
  assert is_field(join(valueOf(args[0].z)));
  assert is_field(join(valueOf(args[1].x)));
  assert is_field(join(valueOf(args[1].y)));
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let res =
    ec_full_add(
      { x = join(valueOf(args[0].x)) ; y = join(valueOf(args[0].y)) ; z = join(valueOf(args[0].z)) },
      { x = join(valueOf(args[1].x)) ; y = join(valueOf(args[1].y)) }
      );
  ensure valueOf(args[0].x) := split(res.x) : [12][32];
  ensure valueOf(args[0].y) := split(res.y) : [12][32];
  ensure valueOf(args[0].z) := split(res.z) : [12][32];
  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
};

// ec_full_sub {{{2
method com.galois.ecc.P384ECC64.ec_full_sub {
  var args[0] :: com.galois.ecc.JacobianPoint;
  var args[1] :: com.galois.ecc.AffinePoint;
  var this.a  :: int[24];
  var this.t1, this.t2, this.t3 :: int[12];
  var args[0].x, args[0].y, args[0].z :: int[12];
  var args[1].x, args[1].y            :: int[12];
  assert is_field(join(valueOf(args[0].x)));
  assert is_field(join(valueOf(args[0].y)));
  assert is_field(join(valueOf(args[0].z)));
  assert is_field(join(valueOf(args[1].x)));
  assert is_field(join(valueOf(args[1].y)));
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let res =
    ec_full_sub(
      { x = join(valueOf(args[0].x)) ; y = join(valueOf(args[0].y)) ; z = join(valueOf(args[0].z)) },
      { x = join(valueOf(args[1].x)) ; y = join(valueOf(args[1].y)) }
      );
  ensure valueOf(args[0].x) := split(res.x) : [12][32];
  ensure valueOf(args[0].y) := split(res.y) : [12][32];
  ensure valueOf(args[0].z) := split(res.z) : [12][32];
  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
};

// ec_mul_merge_aux {{{2
method com.galois.ecc.P384ECC64.ec_mul_merge_aux {
  var args[0] :: com.galois.ecc.JacobianPoint;
  var args[1] :: com.galois.ecc.AffinePoint;
  var args[2] :: int;
  var args[3] :: int;
  var args[4] :: int;
  var this.a :: int[24];
  var this.t1, this.t2, this.t3 :: int[12];
  var args[0].x, args[0].y, args[0].z :: int[12];
  var args[1].x, args[1].y :: int[12];
  assert is_field(join(valueOf(args[0].x)));
  assert is_field(join(valueOf(args[0].y)));
  assert is_field(join(valueOf(args[0].z)));
  assert is_field(join(valueOf(args[1].x)));
  assert is_field(join(valueOf(args[1].y)));
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let res = ec_mul_aux({ x = join(valueOf(args[0].x))
                       ; y = join(valueOf(args[0].y))
                       ; z = join(valueOf(args[0].z))
                       },
                       { x = join(valueOf(args[1].x))
                       ; y = join(valueOf(args[1].y))
                       },
                       args[2],
                       args[3],
                       args[4]);
  ensure valueOf(args[0].x) := split(res.x) : [12][32];
  ensure valueOf(args[0].y) := split(res.y) : [12][32];
  ensure valueOf(args[0].z) := split(res.z) : [12][32];
  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  //verify rewrite;
};

// ec_mul {{{2
method com.galois.ecc.P384ECC64.ec_mul {

  var args[0] :: com.galois.ecc.JacobianPoint;
  var args[0].x, args[0].y, args[0].z :: int[12];
  var args[1] :: int[12];
  var args[2] :: com.galois.ecc.AffinePoint;
  var args[2].x, args[2].y            :: int[12];

  var this.a  :: int[24];
  var this.h  :: int[12];
  var this.t1, this.t2, this.t3       :: int[12];

  assert is_field(join(valueOf(args[1])));
  assert is_field(join(valueOf(args[2].x)));
  assert is_field(join(valueOf(args[2].y)));

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  /*
  localSpec 162 {
      let lres = ec_mul_aux(
                   { x = join(valueOf(args[0].x))
                   ; y = join(valueOf(args[0].y))
                   ; z = join(valueOf(args[0].z))
                   },
                   { x = join(valueOf(args[2].x))
                   ; y = join(valueOf(args[2].y))
                   },
                   TODO,
                   TODO,
                   TODO);
      ensure: valueOf(args[0].x) := split(lres.x);
      ensure: valueOf(args[0].y) := split(lres.y);
      ensure: valueOf(args[0].z) := split(lres.z);

  }
  */

  let res = ec_mul(join(valueOf(args[1])),
                   { x = join(valueOf(args[2].x))
                   ; y = join(valueOf(args[2].y))
                   });

  ensure valueOf(args[0].x) := split(res.x) : [12][32];
  ensure valueOf(args[0].y) := split(res.y) : [12][32];
  ensure valueOf(args[0].z) := split(res.z) : [12][32];
  /*modify valueOf(args[0].x), valueOf(args[0].y), valueOf(args[0].z);*/
  modify valueOf(this.a), valueOf(this.h), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);

};
